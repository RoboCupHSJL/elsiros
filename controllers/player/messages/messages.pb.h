// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
class AccelerometerMeasurement;
struct AccelerometerMeasurementDefaultTypeInternal;
extern AccelerometerMeasurementDefaultTypeInternal _AccelerometerMeasurement_default_instance_;
class ActuatorRequests;
struct ActuatorRequestsDefaultTypeInternal;
extern ActuatorRequestsDefaultTypeInternal _ActuatorRequests_default_instance_;
class BumperMeasurement;
struct BumperMeasurementDefaultTypeInternal;
extern BumperMeasurementDefaultTypeInternal _BumperMeasurement_default_instance_;
class CameraExposure;
struct CameraExposureDefaultTypeInternal;
extern CameraExposureDefaultTypeInternal _CameraExposure_default_instance_;
class CameraMeasurement;
struct CameraMeasurementDefaultTypeInternal;
extern CameraMeasurementDefaultTypeInternal _CameraMeasurement_default_instance_;
class CameraQuality;
struct CameraQualityDefaultTypeInternal;
extern CameraQualityDefaultTypeInternal _CameraQuality_default_instance_;
class DetectionMeasurement;
struct DetectionMeasurementDefaultTypeInternal;
extern DetectionMeasurementDefaultTypeInternal _DetectionMeasurement_default_instance_;
class Force3DMeasurement;
struct Force3DMeasurementDefaultTypeInternal;
extern Force3DMeasurementDefaultTypeInternal _Force3DMeasurement_default_instance_;
class Force6DMeasurement;
struct Force6DMeasurementDefaultTypeInternal;
extern Force6DMeasurementDefaultTypeInternal _Force6DMeasurement_default_instance_;
class ForceMeasurement;
struct ForceMeasurementDefaultTypeInternal;
extern ForceMeasurementDefaultTypeInternal _ForceMeasurement_default_instance_;
class GPSMeasurement;
struct GPSMeasurementDefaultTypeInternal;
extern GPSMeasurementDefaultTypeInternal _GPSMeasurement_default_instance_;
class GyroMeasurement;
struct GyroMeasurementDefaultTypeInternal;
extern GyroMeasurementDefaultTypeInternal _GyroMeasurement_default_instance_;
class IMUSensorMeasurement;
struct IMUSensorMeasurementDefaultTypeInternal;
extern IMUSensorMeasurementDefaultTypeInternal _IMUSensorMeasurement_default_instance_;
class IMUVector;
struct IMUVectorDefaultTypeInternal;
extern IMUVectorDefaultTypeInternal _IMUVector_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MotorForce;
struct MotorForceDefaultTypeInternal;
extern MotorForceDefaultTypeInternal _MotorForce_default_instance_;
class MotorPID;
struct MotorPIDDefaultTypeInternal;
extern MotorPIDDefaultTypeInternal _MotorPID_default_instance_;
class MotorPosition;
struct MotorPositionDefaultTypeInternal;
extern MotorPositionDefaultTypeInternal _MotorPosition_default_instance_;
class MotorTorque;
struct MotorTorqueDefaultTypeInternal;
extern MotorTorqueDefaultTypeInternal _MotorTorque_default_instance_;
class MotorVelocity;
struct MotorVelocityDefaultTypeInternal;
extern MotorVelocityDefaultTypeInternal _MotorVelocity_default_instance_;
class PositionSensorMeasurement;
struct PositionSensorMeasurementDefaultTypeInternal;
extern PositionSensorMeasurementDefaultTypeInternal _PositionSensorMeasurement_default_instance_;
class SensorMeasurements;
struct SensorMeasurementsDefaultTypeInternal;
extern SensorMeasurementsDefaultTypeInternal _SensorMeasurements_default_instance_;
class SensorTimeStep;
struct SensorTimeStepDefaultTypeInternal;
extern SensorTimeStepDefaultTypeInternal _SensorTimeStep_default_instance_;
class Vector2Int;
struct Vector2IntDefaultTypeInternal;
extern Vector2IntDefaultTypeInternal _Vector2Int_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AccelerometerMeasurement* Arena::CreateMaybeMessage<::AccelerometerMeasurement>(Arena*);
template<> ::ActuatorRequests* Arena::CreateMaybeMessage<::ActuatorRequests>(Arena*);
template<> ::BumperMeasurement* Arena::CreateMaybeMessage<::BumperMeasurement>(Arena*);
template<> ::CameraExposure* Arena::CreateMaybeMessage<::CameraExposure>(Arena*);
template<> ::CameraMeasurement* Arena::CreateMaybeMessage<::CameraMeasurement>(Arena*);
template<> ::CameraQuality* Arena::CreateMaybeMessage<::CameraQuality>(Arena*);
template<> ::DetectionMeasurement* Arena::CreateMaybeMessage<::DetectionMeasurement>(Arena*);
template<> ::Force3DMeasurement* Arena::CreateMaybeMessage<::Force3DMeasurement>(Arena*);
template<> ::Force6DMeasurement* Arena::CreateMaybeMessage<::Force6DMeasurement>(Arena*);
template<> ::ForceMeasurement* Arena::CreateMaybeMessage<::ForceMeasurement>(Arena*);
template<> ::GPSMeasurement* Arena::CreateMaybeMessage<::GPSMeasurement>(Arena*);
template<> ::GyroMeasurement* Arena::CreateMaybeMessage<::GyroMeasurement>(Arena*);
template<> ::IMUSensorMeasurement* Arena::CreateMaybeMessage<::IMUSensorMeasurement>(Arena*);
template<> ::IMUVector* Arena::CreateMaybeMessage<::IMUVector>(Arena*);
template<> ::Message* Arena::CreateMaybeMessage<::Message>(Arena*);
template<> ::MotorForce* Arena::CreateMaybeMessage<::MotorForce>(Arena*);
template<> ::MotorPID* Arena::CreateMaybeMessage<::MotorPID>(Arena*);
template<> ::MotorPosition* Arena::CreateMaybeMessage<::MotorPosition>(Arena*);
template<> ::MotorTorque* Arena::CreateMaybeMessage<::MotorTorque>(Arena*);
template<> ::MotorVelocity* Arena::CreateMaybeMessage<::MotorVelocity>(Arena*);
template<> ::PositionSensorMeasurement* Arena::CreateMaybeMessage<::PositionSensorMeasurement>(Arena*);
template<> ::SensorMeasurements* Arena::CreateMaybeMessage<::SensorMeasurements>(Arena*);
template<> ::SensorTimeStep* Arena::CreateMaybeMessage<::SensorTimeStep>(Arena*);
template<> ::Vector2Int* Arena::CreateMaybeMessage<::Vector2Int>(Arena*);
template<> ::Vector3* Arena::CreateMaybeMessage<::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Message_MessageType : int {
  Message_MessageType_ERROR_MESSAGE = 0,
  Message_MessageType_WARNING_MESSAGE = 1,
  Message_MessageType_Message_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Message_MessageType_Message_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Message_MessageType_IsValid(int value);
constexpr Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_ERROR_MESSAGE;
constexpr Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_WARNING_MESSAGE;
constexpr int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_MessageType_descriptor();
template<typename T>
inline const std::string& Message_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_MessageType_descriptor(), enum_t_value);
}
inline bool Message_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Message_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
// ===================================================================

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit constexpr Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return new Vector3();
  }

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double X = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double Y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double Z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class IMUVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMUVector) */ {
 public:
  inline IMUVector() : IMUVector(nullptr) {}
  ~IMUVector() override;
  explicit constexpr IMUVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMUVector(const IMUVector& from);
  IMUVector(IMUVector&& from) noexcept
    : IMUVector() {
    *this = ::std::move(from);
  }

  inline IMUVector& operator=(const IMUVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUVector& operator=(IMUVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUVector* internal_default_instance() {
    return reinterpret_cast<const IMUVector*>(
               &_IMUVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IMUVector& a, IMUVector& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMUVector* New() const final {
    return new IMUVector();
  }

  IMUVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMUVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMUVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMUVector& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMUVector";
  }
  protected:
  explicit IMUVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
    kRollFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // double pitch = 1;
  void clear_pitch();
  double pitch() const;
  void set_pitch(double value);
  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);
  public:

  // double roll = 2;
  void clear_roll();
  double roll() const;
  void set_roll(double value);
  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);
  public:

  // double yaw = 3;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // @@protoc_insertion_point(class_scope:IMUVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double pitch_;
  double roll_;
  double yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Vector2Int final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vector2Int) */ {
 public:
  inline Vector2Int() : Vector2Int(nullptr) {}
  ~Vector2Int() override;
  explicit constexpr Vector2Int(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2Int(const Vector2Int& from);
  Vector2Int(Vector2Int&& from) noexcept
    : Vector2Int() {
    *this = ::std::move(from);
  }

  inline Vector2Int& operator=(const Vector2Int& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2Int& operator=(Vector2Int&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2Int& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2Int* internal_default_instance() {
    return reinterpret_cast<const Vector2Int*>(
               &_Vector2Int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vector2Int& a, Vector2Int& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2Int* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2Int* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector2Int* New() const final {
    return new Vector2Int();
  }

  Vector2Int* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector2Int>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2Int& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector2Int& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2Int* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vector2Int";
  }
  protected:
  explicit Vector2Int(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 X = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Vector2Int)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class IMUSensorMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMUSensorMeasurement) */ {
 public:
  inline IMUSensorMeasurement() : IMUSensorMeasurement(nullptr) {}
  ~IMUSensorMeasurement() override;
  explicit constexpr IMUSensorMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMUSensorMeasurement(const IMUSensorMeasurement& from);
  IMUSensorMeasurement(IMUSensorMeasurement&& from) noexcept
    : IMUSensorMeasurement() {
    *this = ::std::move(from);
  }

  inline IMUSensorMeasurement& operator=(const IMUSensorMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUSensorMeasurement& operator=(IMUSensorMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUSensorMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUSensorMeasurement* internal_default_instance() {
    return reinterpret_cast<const IMUSensorMeasurement*>(
               &_IMUSensorMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IMUSensorMeasurement& a, IMUSensorMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUSensorMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUSensorMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IMUSensorMeasurement* New() const final {
    return new IMUSensorMeasurement();
  }

  IMUSensorMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IMUSensorMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMUSensorMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IMUSensorMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUSensorMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMUSensorMeasurement";
  }
  protected:
  explicit IMUSensorMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAnglesFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .IMUVector angles = 2;
  bool has_angles() const;
  private:
  bool _internal_has_angles() const;
  public:
  void clear_angles();
  const ::IMUVector& angles() const;
  PROTOBUF_MUST_USE_RESULT ::IMUVector* release_angles();
  ::IMUVector* mutable_angles();
  void set_allocated_angles(::IMUVector* angles);
  private:
  const ::IMUVector& _internal_angles() const;
  ::IMUVector* _internal_mutable_angles();
  public:
  void unsafe_arena_set_allocated_angles(
      ::IMUVector* angles);
  ::IMUVector* unsafe_arena_release_angles();

  // @@protoc_insertion_point(class_scope:IMUSensorMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::IMUVector* angles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class PositionSensorMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PositionSensorMeasurement) */ {
 public:
  inline PositionSensorMeasurement() : PositionSensorMeasurement(nullptr) {}
  ~PositionSensorMeasurement() override;
  explicit constexpr PositionSensorMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionSensorMeasurement(const PositionSensorMeasurement& from);
  PositionSensorMeasurement(PositionSensorMeasurement&& from) noexcept
    : PositionSensorMeasurement() {
    *this = ::std::move(from);
  }

  inline PositionSensorMeasurement& operator=(const PositionSensorMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionSensorMeasurement& operator=(PositionSensorMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionSensorMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionSensorMeasurement* internal_default_instance() {
    return reinterpret_cast<const PositionSensorMeasurement*>(
               &_PositionSensorMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PositionSensorMeasurement& a, PositionSensorMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionSensorMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionSensorMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PositionSensorMeasurement* New() const final {
    return new PositionSensorMeasurement();
  }

  PositionSensorMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PositionSensorMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionSensorMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PositionSensorMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionSensorMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PositionSensorMeasurement";
  }
  protected:
  explicit PositionSensorMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:PositionSensorMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class GPSMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GPSMeasurement) */ {
 public:
  inline GPSMeasurement() : GPSMeasurement(nullptr) {}
  ~GPSMeasurement() override;
  explicit constexpr GPSMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPSMeasurement(const GPSMeasurement& from);
  GPSMeasurement(GPSMeasurement&& from) noexcept
    : GPSMeasurement() {
    *this = ::std::move(from);
  }

  inline GPSMeasurement& operator=(const GPSMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPSMeasurement& operator=(GPSMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPSMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPSMeasurement* internal_default_instance() {
    return reinterpret_cast<const GPSMeasurement*>(
               &_GPSMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GPSMeasurement& a, GPSMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(GPSMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPSMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GPSMeasurement* New() const final {
    return new GPSMeasurement();
  }

  GPSMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GPSMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GPSMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GPSMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPSMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GPSMeasurement";
  }
  protected:
  explicit GPSMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector3 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Vector3& value() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);
  private:
  const ::Vector3& _internal_value() const;
  ::Vector3* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::Vector3* value);
  ::Vector3* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:GPSMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class DetectionMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DetectionMeasurement) */ {
 public:
  inline DetectionMeasurement() : DetectionMeasurement(nullptr) {}
  ~DetectionMeasurement() override;
  explicit constexpr DetectionMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectionMeasurement(const DetectionMeasurement& from);
  DetectionMeasurement(DetectionMeasurement&& from) noexcept
    : DetectionMeasurement() {
    *this = ::std::move(from);
  }

  inline DetectionMeasurement& operator=(const DetectionMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionMeasurement& operator=(DetectionMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectionMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionMeasurement* internal_default_instance() {
    return reinterpret_cast<const DetectionMeasurement*>(
               &_DetectionMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DetectionMeasurement& a, DetectionMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetectionMeasurement* New() const final {
    return new DetectionMeasurement();
  }

  DetectionMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetectionMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectionMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectionMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DetectionMeasurement";
  }
  protected:
  explicit DetectionMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPositionOnImageFieldNumber = 2,
    kSizeOnImageFieldNumber = 3,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector2Int position_on_image = 2;
  bool has_position_on_image() const;
  private:
  bool _internal_has_position_on_image() const;
  public:
  void clear_position_on_image();
  const ::Vector2Int& position_on_image() const;
  PROTOBUF_MUST_USE_RESULT ::Vector2Int* release_position_on_image();
  ::Vector2Int* mutable_position_on_image();
  void set_allocated_position_on_image(::Vector2Int* position_on_image);
  private:
  const ::Vector2Int& _internal_position_on_image() const;
  ::Vector2Int* _internal_mutable_position_on_image();
  public:
  void unsafe_arena_set_allocated_position_on_image(
      ::Vector2Int* position_on_image);
  ::Vector2Int* unsafe_arena_release_position_on_image();

  // .Vector2Int size_on_image = 3;
  bool has_size_on_image() const;
  private:
  bool _internal_has_size_on_image() const;
  public:
  void clear_size_on_image();
  const ::Vector2Int& size_on_image() const;
  PROTOBUF_MUST_USE_RESULT ::Vector2Int* release_size_on_image();
  ::Vector2Int* mutable_size_on_image();
  void set_allocated_size_on_image(::Vector2Int* size_on_image);
  private:
  const ::Vector2Int& _internal_size_on_image() const;
  ::Vector2Int* _internal_mutable_size_on_image();
  public:
  void unsafe_arena_set_allocated_size_on_image(
      ::Vector2Int* size_on_image);
  ::Vector2Int* unsafe_arena_release_size_on_image();

  // double X = 4;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double Y = 5;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:DetectionMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector2Int* position_on_image_;
  ::Vector2Int* size_on_image_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class AccelerometerMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AccelerometerMeasurement) */ {
 public:
  inline AccelerometerMeasurement() : AccelerometerMeasurement(nullptr) {}
  ~AccelerometerMeasurement() override;
  explicit constexpr AccelerometerMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccelerometerMeasurement(const AccelerometerMeasurement& from);
  AccelerometerMeasurement(AccelerometerMeasurement&& from) noexcept
    : AccelerometerMeasurement() {
    *this = ::std::move(from);
  }

  inline AccelerometerMeasurement& operator=(const AccelerometerMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelerometerMeasurement& operator=(AccelerometerMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccelerometerMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccelerometerMeasurement* internal_default_instance() {
    return reinterpret_cast<const AccelerometerMeasurement*>(
               &_AccelerometerMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AccelerometerMeasurement& a, AccelerometerMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelerometerMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelerometerMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccelerometerMeasurement* New() const final {
    return new AccelerometerMeasurement();
  }

  AccelerometerMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccelerometerMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccelerometerMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccelerometerMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerometerMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AccelerometerMeasurement";
  }
  protected:
  explicit AccelerometerMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector3 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Vector3& value() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);
  private:
  const ::Vector3& _internal_value() const;
  ::Vector3* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::Vector3* value);
  ::Vector3* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:AccelerometerMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class GyroMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GyroMeasurement) */ {
 public:
  inline GyroMeasurement() : GyroMeasurement(nullptr) {}
  ~GyroMeasurement() override;
  explicit constexpr GyroMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GyroMeasurement(const GyroMeasurement& from);
  GyroMeasurement(GyroMeasurement&& from) noexcept
    : GyroMeasurement() {
    *this = ::std::move(from);
  }

  inline GyroMeasurement& operator=(const GyroMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline GyroMeasurement& operator=(GyroMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GyroMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const GyroMeasurement* internal_default_instance() {
    return reinterpret_cast<const GyroMeasurement*>(
               &_GyroMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GyroMeasurement& a, GyroMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(GyroMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GyroMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GyroMeasurement* New() const final {
    return new GyroMeasurement();
  }

  GyroMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GyroMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GyroMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GyroMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GyroMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GyroMeasurement";
  }
  protected:
  explicit GyroMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector3 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Vector3& value() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);
  private:
  const ::Vector3& _internal_value() const;
  ::Vector3* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::Vector3* value);
  ::Vector3* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:GyroMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class BumperMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BumperMeasurement) */ {
 public:
  inline BumperMeasurement() : BumperMeasurement(nullptr) {}
  ~BumperMeasurement() override;
  explicit constexpr BumperMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BumperMeasurement(const BumperMeasurement& from);
  BumperMeasurement(BumperMeasurement&& from) noexcept
    : BumperMeasurement() {
    *this = ::std::move(from);
  }

  inline BumperMeasurement& operator=(const BumperMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline BumperMeasurement& operator=(BumperMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BumperMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const BumperMeasurement* internal_default_instance() {
    return reinterpret_cast<const BumperMeasurement*>(
               &_BumperMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BumperMeasurement& a, BumperMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(BumperMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BumperMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BumperMeasurement* New() const final {
    return new BumperMeasurement();
  }

  BumperMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BumperMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BumperMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BumperMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BumperMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BumperMeasurement";
  }
  protected:
  explicit BumperMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool value = 2;
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:BumperMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ForceMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ForceMeasurement) */ {
 public:
  inline ForceMeasurement() : ForceMeasurement(nullptr) {}
  ~ForceMeasurement() override;
  explicit constexpr ForceMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForceMeasurement(const ForceMeasurement& from);
  ForceMeasurement(ForceMeasurement&& from) noexcept
    : ForceMeasurement() {
    *this = ::std::move(from);
  }

  inline ForceMeasurement& operator=(const ForceMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForceMeasurement& operator=(ForceMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForceMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForceMeasurement* internal_default_instance() {
    return reinterpret_cast<const ForceMeasurement*>(
               &_ForceMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ForceMeasurement& a, ForceMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(ForceMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForceMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ForceMeasurement* New() const final {
    return new ForceMeasurement();
  }

  ForceMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ForceMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForceMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ForceMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForceMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ForceMeasurement";
  }
  protected:
  explicit ForceMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:ForceMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Force3DMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Force3DMeasurement) */ {
 public:
  inline Force3DMeasurement() : Force3DMeasurement(nullptr) {}
  ~Force3DMeasurement() override;
  explicit constexpr Force3DMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Force3DMeasurement(const Force3DMeasurement& from);
  Force3DMeasurement(Force3DMeasurement&& from) noexcept
    : Force3DMeasurement() {
    *this = ::std::move(from);
  }

  inline Force3DMeasurement& operator=(const Force3DMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Force3DMeasurement& operator=(Force3DMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Force3DMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Force3DMeasurement* internal_default_instance() {
    return reinterpret_cast<const Force3DMeasurement*>(
               &_Force3DMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Force3DMeasurement& a, Force3DMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(Force3DMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Force3DMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Force3DMeasurement* New() const final {
    return new Force3DMeasurement();
  }

  Force3DMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Force3DMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Force3DMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Force3DMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Force3DMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Force3DMeasurement";
  }
  protected:
  explicit Force3DMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector3 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Vector3& value() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_value();
  ::Vector3* mutable_value();
  void set_allocated_value(::Vector3* value);
  private:
  const ::Vector3& _internal_value() const;
  ::Vector3* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::Vector3* value);
  ::Vector3* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:Force3DMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector3* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Force6DMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Force6DMeasurement) */ {
 public:
  inline Force6DMeasurement() : Force6DMeasurement(nullptr) {}
  ~Force6DMeasurement() override;
  explicit constexpr Force6DMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Force6DMeasurement(const Force6DMeasurement& from);
  Force6DMeasurement(Force6DMeasurement&& from) noexcept
    : Force6DMeasurement() {
    *this = ::std::move(from);
  }

  inline Force6DMeasurement& operator=(const Force6DMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Force6DMeasurement& operator=(Force6DMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Force6DMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Force6DMeasurement* internal_default_instance() {
    return reinterpret_cast<const Force6DMeasurement*>(
               &_Force6DMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Force6DMeasurement& a, Force6DMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(Force6DMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Force6DMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Force6DMeasurement* New() const final {
    return new Force6DMeasurement();
  }

  Force6DMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Force6DMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Force6DMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Force6DMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Force6DMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Force6DMeasurement";
  }
  protected:
  explicit Force6DMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kForceFieldNumber = 2,
    kTorqueFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector3 force = 2;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  const ::Vector3& force() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_force();
  ::Vector3* mutable_force();
  void set_allocated_force(::Vector3* force);
  private:
  const ::Vector3& _internal_force() const;
  ::Vector3* _internal_mutable_force();
  public:
  void unsafe_arena_set_allocated_force(
      ::Vector3* force);
  ::Vector3* unsafe_arena_release_force();

  // .Vector3 torque = 3;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  const ::Vector3& torque() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_torque();
  ::Vector3* mutable_torque();
  void set_allocated_torque(::Vector3* torque);
  private:
  const ::Vector3& _internal_torque() const;
  ::Vector3* _internal_mutable_torque();
  public:
  void unsafe_arena_set_allocated_torque(
      ::Vector3* torque);
  ::Vector3* unsafe_arena_release_torque();

  // @@protoc_insertion_point(class_scope:Force6DMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector3* force_;
  ::Vector3* torque_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CameraMeasurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraMeasurement) */ {
 public:
  inline CameraMeasurement() : CameraMeasurement(nullptr) {}
  ~CameraMeasurement() override;
  explicit constexpr CameraMeasurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraMeasurement(const CameraMeasurement& from);
  CameraMeasurement(CameraMeasurement&& from) noexcept
    : CameraMeasurement() {
    *this = ::std::move(from);
  }

  inline CameraMeasurement& operator=(const CameraMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraMeasurement& operator=(CameraMeasurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraMeasurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraMeasurement* internal_default_instance() {
    return reinterpret_cast<const CameraMeasurement*>(
               &_CameraMeasurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CameraMeasurement& a, CameraMeasurement& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraMeasurement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraMeasurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraMeasurement* New() const final {
    return new CameraMeasurement();
  }

  CameraMeasurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraMeasurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraMeasurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CameraMeasurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraMeasurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraMeasurement";
  }
  protected:
  explicit CameraMeasurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kImageFieldNumber = 5,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kQualityFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes image = 5;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_MUST_USE_RESULT std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // uint32 width = 2;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // sint32 quality = 4;
  void clear_quality();
  ::PROTOBUF_NAMESPACE_ID::int32 quality() const;
  void set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_quality() const;
  void _internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:CameraMeasurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 quality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return new Message();
  }

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_MessageType MessageType;
  static constexpr MessageType ERROR_MESSAGE =
    Message_MessageType_ERROR_MESSAGE;
  static constexpr MessageType WARNING_MESSAGE =
    Message_MessageType_WARNING_MESSAGE;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return Message_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .Message.MessageType message_type = 1;
  void clear_message_type();
  ::Message_MessageType message_type() const;
  void set_message_type(::Message_MessageType value);
  private:
  ::Message_MessageType _internal_message_type() const;
  void _internal_set_message_type(::Message_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int message_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorMeasurements final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorMeasurements) */ {
 public:
  inline SensorMeasurements() : SensorMeasurements(nullptr) {}
  ~SensorMeasurements() override;
  explicit constexpr SensorMeasurements(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorMeasurements(const SensorMeasurements& from);
  SensorMeasurements(SensorMeasurements&& from) noexcept
    : SensorMeasurements() {
    *this = ::std::move(from);
  }

  inline SensorMeasurements& operator=(const SensorMeasurements& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorMeasurements& operator=(SensorMeasurements&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorMeasurements& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorMeasurements* internal_default_instance() {
    return reinterpret_cast<const SensorMeasurements*>(
               &_SensorMeasurements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SensorMeasurements& a, SensorMeasurements& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorMeasurements* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorMeasurements* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorMeasurements* New() const final {
    return new SensorMeasurements();
  }

  SensorMeasurements* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorMeasurements>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorMeasurements& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorMeasurements& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorMeasurements* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorMeasurements";
  }
  protected:
  explicit SensorMeasurements(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 3,
    kAccelerometersFieldNumber = 4,
    kBumpersFieldNumber = 5,
    kCamerasFieldNumber = 6,
    kForcesFieldNumber = 7,
    kForce3DsFieldNumber = 8,
    kForce6DsFieldNumber = 9,
    kGyrosFieldNumber = 10,
    kPositionSensorsFieldNumber = 11,
    kGpsFieldNumber = 12,
    kObjectsFieldNumber = 13,
    kImuFieldNumber = 14,
    kRealTimeFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // repeated .Message messages = 3;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message >*
      mutable_messages();
  private:
  const ::Message& _internal_messages(int index) const;
  ::Message* _internal_add_messages();
  public:
  const ::Message& messages(int index) const;
  ::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message >&
      messages() const;

  // repeated .AccelerometerMeasurement accelerometers = 4;
  int accelerometers_size() const;
  private:
  int _internal_accelerometers_size() const;
  public:
  void clear_accelerometers();
  ::AccelerometerMeasurement* mutable_accelerometers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AccelerometerMeasurement >*
      mutable_accelerometers();
  private:
  const ::AccelerometerMeasurement& _internal_accelerometers(int index) const;
  ::AccelerometerMeasurement* _internal_add_accelerometers();
  public:
  const ::AccelerometerMeasurement& accelerometers(int index) const;
  ::AccelerometerMeasurement* add_accelerometers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AccelerometerMeasurement >&
      accelerometers() const;

  // repeated .BumperMeasurement bumpers = 5;
  int bumpers_size() const;
  private:
  int _internal_bumpers_size() const;
  public:
  void clear_bumpers();
  ::BumperMeasurement* mutable_bumpers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BumperMeasurement >*
      mutable_bumpers();
  private:
  const ::BumperMeasurement& _internal_bumpers(int index) const;
  ::BumperMeasurement* _internal_add_bumpers();
  public:
  const ::BumperMeasurement& bumpers(int index) const;
  ::BumperMeasurement* add_bumpers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BumperMeasurement >&
      bumpers() const;

  // repeated .CameraMeasurement cameras = 6;
  int cameras_size() const;
  private:
  int _internal_cameras_size() const;
  public:
  void clear_cameras();
  ::CameraMeasurement* mutable_cameras(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraMeasurement >*
      mutable_cameras();
  private:
  const ::CameraMeasurement& _internal_cameras(int index) const;
  ::CameraMeasurement* _internal_add_cameras();
  public:
  const ::CameraMeasurement& cameras(int index) const;
  ::CameraMeasurement* add_cameras();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraMeasurement >&
      cameras() const;

  // repeated .ForceMeasurement forces = 7;
  int forces_size() const;
  private:
  int _internal_forces_size() const;
  public:
  void clear_forces();
  ::ForceMeasurement* mutable_forces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ForceMeasurement >*
      mutable_forces();
  private:
  const ::ForceMeasurement& _internal_forces(int index) const;
  ::ForceMeasurement* _internal_add_forces();
  public:
  const ::ForceMeasurement& forces(int index) const;
  ::ForceMeasurement* add_forces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ForceMeasurement >&
      forces() const;

  // repeated .Force3DMeasurement force3ds = 8;
  int force3ds_size() const;
  private:
  int _internal_force3ds_size() const;
  public:
  void clear_force3ds();
  ::Force3DMeasurement* mutable_force3ds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force3DMeasurement >*
      mutable_force3ds();
  private:
  const ::Force3DMeasurement& _internal_force3ds(int index) const;
  ::Force3DMeasurement* _internal_add_force3ds();
  public:
  const ::Force3DMeasurement& force3ds(int index) const;
  ::Force3DMeasurement* add_force3ds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force3DMeasurement >&
      force3ds() const;

  // repeated .Force6DMeasurement force6ds = 9;
  int force6ds_size() const;
  private:
  int _internal_force6ds_size() const;
  public:
  void clear_force6ds();
  ::Force6DMeasurement* mutable_force6ds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force6DMeasurement >*
      mutable_force6ds();
  private:
  const ::Force6DMeasurement& _internal_force6ds(int index) const;
  ::Force6DMeasurement* _internal_add_force6ds();
  public:
  const ::Force6DMeasurement& force6ds(int index) const;
  ::Force6DMeasurement* add_force6ds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force6DMeasurement >&
      force6ds() const;

  // repeated .GyroMeasurement gyros = 10;
  int gyros_size() const;
  private:
  int _internal_gyros_size() const;
  public:
  void clear_gyros();
  ::GyroMeasurement* mutable_gyros(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GyroMeasurement >*
      mutable_gyros();
  private:
  const ::GyroMeasurement& _internal_gyros(int index) const;
  ::GyroMeasurement* _internal_add_gyros();
  public:
  const ::GyroMeasurement& gyros(int index) const;
  ::GyroMeasurement* add_gyros();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GyroMeasurement >&
      gyros() const;

  // repeated .PositionSensorMeasurement position_sensors = 11;
  int position_sensors_size() const;
  private:
  int _internal_position_sensors_size() const;
  public:
  void clear_position_sensors();
  ::PositionSensorMeasurement* mutable_position_sensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PositionSensorMeasurement >*
      mutable_position_sensors();
  private:
  const ::PositionSensorMeasurement& _internal_position_sensors(int index) const;
  ::PositionSensorMeasurement* _internal_add_position_sensors();
  public:
  const ::PositionSensorMeasurement& position_sensors(int index) const;
  ::PositionSensorMeasurement* add_position_sensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PositionSensorMeasurement >&
      position_sensors() const;

  // repeated .GPSMeasurement gps = 12;
  int gps_size() const;
  private:
  int _internal_gps_size() const;
  public:
  void clear_gps();
  ::GPSMeasurement* mutable_gps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GPSMeasurement >*
      mutable_gps();
  private:
  const ::GPSMeasurement& _internal_gps(int index) const;
  ::GPSMeasurement* _internal_add_gps();
  public:
  const ::GPSMeasurement& gps(int index) const;
  ::GPSMeasurement* add_gps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GPSMeasurement >&
      gps() const;

  // repeated .DetectionMeasurement objects = 13;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::DetectionMeasurement* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DetectionMeasurement >*
      mutable_objects();
  private:
  const ::DetectionMeasurement& _internal_objects(int index) const;
  ::DetectionMeasurement* _internal_add_objects();
  public:
  const ::DetectionMeasurement& objects(int index) const;
  ::DetectionMeasurement* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DetectionMeasurement >&
      objects() const;

  // repeated .IMUSensorMeasurement imu = 14;
  int imu_size() const;
  private:
  int _internal_imu_size() const;
  public:
  void clear_imu();
  ::IMUSensorMeasurement* mutable_imu(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMUSensorMeasurement >*
      mutable_imu();
  private:
  const ::IMUSensorMeasurement& _internal_imu(int index) const;
  ::IMUSensorMeasurement* _internal_add_imu();
  public:
  const ::IMUSensorMeasurement& imu(int index) const;
  ::IMUSensorMeasurement* add_imu();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMUSensorMeasurement >&
      imu() const;

  // uint64 real_time = 2;
  void clear_real_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 real_time() const;
  void set_real_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_real_time() const;
  void _internal_set_real_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 time = 1;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SensorMeasurements)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message > messages_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AccelerometerMeasurement > accelerometers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BumperMeasurement > bumpers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraMeasurement > cameras_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ForceMeasurement > forces_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force3DMeasurement > force3ds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force6DMeasurement > force6ds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GyroMeasurement > gyros_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PositionSensorMeasurement > position_sensors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GPSMeasurement > gps_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DetectionMeasurement > objects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMUSensorMeasurement > imu_;
  ::PROTOBUF_NAMESPACE_ID::uint64 real_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MotorPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorPosition) */ {
 public:
  inline MotorPosition() : MotorPosition(nullptr) {}
  ~MotorPosition() override;
  explicit constexpr MotorPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorPosition(const MotorPosition& from);
  MotorPosition(MotorPosition&& from) noexcept
    : MotorPosition() {
    *this = ::std::move(from);
  }

  inline MotorPosition& operator=(const MotorPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorPosition& operator=(MotorPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorPosition* internal_default_instance() {
    return reinterpret_cast<const MotorPosition*>(
               &_MotorPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MotorPosition& a, MotorPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotorPosition* New() const final {
    return new MotorPosition();
  }

  MotorPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotorPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorPosition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorPosition";
  }
  protected:
  explicit MotorPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double position = 2;
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // @@protoc_insertion_point(class_scope:MotorPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MotorVelocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorVelocity) */ {
 public:
  inline MotorVelocity() : MotorVelocity(nullptr) {}
  ~MotorVelocity() override;
  explicit constexpr MotorVelocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorVelocity(const MotorVelocity& from);
  MotorVelocity(MotorVelocity&& from) noexcept
    : MotorVelocity() {
    *this = ::std::move(from);
  }

  inline MotorVelocity& operator=(const MotorVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorVelocity& operator=(MotorVelocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorVelocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorVelocity* internal_default_instance() {
    return reinterpret_cast<const MotorVelocity*>(
               &_MotorVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MotorVelocity& a, MotorVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorVelocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotorVelocity* New() const final {
    return new MotorVelocity();
  }

  MotorVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotorVelocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorVelocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorVelocity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorVelocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorVelocity";
  }
  protected:
  explicit MotorVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVelocityFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double velocity = 2;
  void clear_velocity();
  double velocity() const;
  void set_velocity(double value);
  private:
  double _internal_velocity() const;
  void _internal_set_velocity(double value);
  public:

  // @@protoc_insertion_point(class_scope:MotorVelocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double velocity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MotorForce final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorForce) */ {
 public:
  inline MotorForce() : MotorForce(nullptr) {}
  ~MotorForce() override;
  explicit constexpr MotorForce(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorForce(const MotorForce& from);
  MotorForce(MotorForce&& from) noexcept
    : MotorForce() {
    *this = ::std::move(from);
  }

  inline MotorForce& operator=(const MotorForce& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorForce& operator=(MotorForce&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorForce& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorForce* internal_default_instance() {
    return reinterpret_cast<const MotorForce*>(
               &_MotorForce_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MotorForce& a, MotorForce& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorForce* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorForce* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotorForce* New() const final {
    return new MotorForce();
  }

  MotorForce* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotorForce>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorForce& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorForce& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorForce* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorForce";
  }
  protected:
  explicit MotorForce(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kForceFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double force = 2;
  void clear_force();
  double force() const;
  void set_force(double value);
  private:
  double _internal_force() const;
  void _internal_set_force(double value);
  public:

  // @@protoc_insertion_point(class_scope:MotorForce)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double force_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MotorTorque final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorTorque) */ {
 public:
  inline MotorTorque() : MotorTorque(nullptr) {}
  ~MotorTorque() override;
  explicit constexpr MotorTorque(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorTorque(const MotorTorque& from);
  MotorTorque(MotorTorque&& from) noexcept
    : MotorTorque() {
    *this = ::std::move(from);
  }

  inline MotorTorque& operator=(const MotorTorque& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorTorque& operator=(MotorTorque&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorTorque& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorTorque* internal_default_instance() {
    return reinterpret_cast<const MotorTorque*>(
               &_MotorTorque_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MotorTorque& a, MotorTorque& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorTorque* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorTorque* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotorTorque* New() const final {
    return new MotorTorque();
  }

  MotorTorque* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotorTorque>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorTorque& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorTorque& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorTorque* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorTorque";
  }
  protected:
  explicit MotorTorque(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTorqueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double torque = 2;
  void clear_torque();
  double torque() const;
  void set_torque(double value);
  private:
  double _internal_torque() const;
  void _internal_set_torque(double value);
  public:

  // @@protoc_insertion_point(class_scope:MotorTorque)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double torque_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MotorPID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MotorPID) */ {
 public:
  inline MotorPID() : MotorPID(nullptr) {}
  ~MotorPID() override;
  explicit constexpr MotorPID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotorPID(const MotorPID& from);
  MotorPID(MotorPID&& from) noexcept
    : MotorPID() {
    *this = ::std::move(from);
  }

  inline MotorPID& operator=(const MotorPID& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotorPID& operator=(MotorPID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotorPID& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotorPID* internal_default_instance() {
    return reinterpret_cast<const MotorPID*>(
               &_MotorPID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MotorPID& a, MotorPID& b) {
    a.Swap(&b);
  }
  inline void Swap(MotorPID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotorPID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotorPID* New() const final {
    return new MotorPID();
  }

  MotorPID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotorPID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotorPID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotorPID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorPID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MotorPID";
  }
  protected:
  explicit MotorPID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPIDFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Vector3 PID = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  const ::Vector3& pid() const;
  PROTOBUF_MUST_USE_RESULT ::Vector3* release_pid();
  ::Vector3* mutable_pid();
  void set_allocated_pid(::Vector3* pid);
  private:
  const ::Vector3& _internal_pid() const;
  ::Vector3* _internal_mutable_pid();
  public:
  void unsafe_arena_set_allocated_pid(
      ::Vector3* pid);
  ::Vector3* unsafe_arena_release_pid();

  // @@protoc_insertion_point(class_scope:MotorPID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Vector3* pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SensorTimeStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorTimeStep) */ {
 public:
  inline SensorTimeStep() : SensorTimeStep(nullptr) {}
  ~SensorTimeStep() override;
  explicit constexpr SensorTimeStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorTimeStep(const SensorTimeStep& from);
  SensorTimeStep(SensorTimeStep&& from) noexcept
    : SensorTimeStep() {
    *this = ::std::move(from);
  }

  inline SensorTimeStep& operator=(const SensorTimeStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorTimeStep& operator=(SensorTimeStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorTimeStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorTimeStep* internal_default_instance() {
    return reinterpret_cast<const SensorTimeStep*>(
               &_SensorTimeStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SensorTimeStep& a, SensorTimeStep& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorTimeStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorTimeStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorTimeStep* New() const final {
    return new SensorTimeStep();
  }

  SensorTimeStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorTimeStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorTimeStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorTimeStep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorTimeStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorTimeStep";
  }
  protected:
  explicit SensorTimeStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTimeStepFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 timeStep = 2;
  void clear_timestep();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestep() const;
  void set_timestep(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestep() const;
  void _internal_set_timestep(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SensorTimeStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CameraQuality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraQuality) */ {
 public:
  inline CameraQuality() : CameraQuality(nullptr) {}
  ~CameraQuality() override;
  explicit constexpr CameraQuality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraQuality(const CameraQuality& from);
  CameraQuality(CameraQuality&& from) noexcept
    : CameraQuality() {
    *this = ::std::move(from);
  }

  inline CameraQuality& operator=(const CameraQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraQuality& operator=(CameraQuality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraQuality& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraQuality* internal_default_instance() {
    return reinterpret_cast<const CameraQuality*>(
               &_CameraQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CameraQuality& a, CameraQuality& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraQuality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraQuality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraQuality* New() const final {
    return new CameraQuality();
  }

  CameraQuality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraQuality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraQuality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CameraQuality& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraQuality* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraQuality";
  }
  protected:
  explicit CameraQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kQualityFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // sint32 quality = 2;
  void clear_quality();
  ::PROTOBUF_NAMESPACE_ID::int32 quality() const;
  void set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_quality() const;
  void _internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:CameraQuality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 quality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CameraExposure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraExposure) */ {
 public:
  inline CameraExposure() : CameraExposure(nullptr) {}
  ~CameraExposure() override;
  explicit constexpr CameraExposure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraExposure(const CameraExposure& from);
  CameraExposure(CameraExposure&& from) noexcept
    : CameraExposure() {
    *this = ::std::move(from);
  }

  inline CameraExposure& operator=(const CameraExposure& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraExposure& operator=(CameraExposure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraExposure& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraExposure* internal_default_instance() {
    return reinterpret_cast<const CameraExposure*>(
               &_CameraExposure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CameraExposure& a, CameraExposure& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraExposure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraExposure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraExposure* New() const final {
    return new CameraExposure();
  }

  CameraExposure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraExposure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraExposure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CameraExposure& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraExposure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraExposure";
  }
  protected:
  explicit CameraExposure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExposureFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double exposure = 2;
  void clear_exposure();
  double exposure() const;
  void set_exposure(double value);
  private:
  double _internal_exposure() const;
  void _internal_set_exposure(double value);
  public:

  // @@protoc_insertion_point(class_scope:CameraExposure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double exposure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ActuatorRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActuatorRequests) */ {
 public:
  inline ActuatorRequests() : ActuatorRequests(nullptr) {}
  ~ActuatorRequests() override;
  explicit constexpr ActuatorRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActuatorRequests(const ActuatorRequests& from);
  ActuatorRequests(ActuatorRequests&& from) noexcept
    : ActuatorRequests() {
    *this = ::std::move(from);
  }

  inline ActuatorRequests& operator=(const ActuatorRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActuatorRequests& operator=(ActuatorRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActuatorRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActuatorRequests* internal_default_instance() {
    return reinterpret_cast<const ActuatorRequests*>(
               &_ActuatorRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ActuatorRequests& a, ActuatorRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(ActuatorRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActuatorRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActuatorRequests* New() const final {
    return new ActuatorRequests();
  }

  ActuatorRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActuatorRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActuatorRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ActuatorRequests& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActuatorRequests* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActuatorRequests";
  }
  protected:
  explicit ActuatorRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotorPositionsFieldNumber = 1,
    kMotorVelocitiesFieldNumber = 2,
    kMotorForcesFieldNumber = 3,
    kMotorTorquesFieldNumber = 4,
    kMotorPidsFieldNumber = 5,
    kSensorTimeStepsFieldNumber = 6,
    kCameraQualitiesFieldNumber = 7,
    kCameraExposuresFieldNumber = 8,
  };
  // repeated .MotorPosition motor_positions = 1;
  int motor_positions_size() const;
  private:
  int _internal_motor_positions_size() const;
  public:
  void clear_motor_positions();
  ::MotorPosition* mutable_motor_positions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPosition >*
      mutable_motor_positions();
  private:
  const ::MotorPosition& _internal_motor_positions(int index) const;
  ::MotorPosition* _internal_add_motor_positions();
  public:
  const ::MotorPosition& motor_positions(int index) const;
  ::MotorPosition* add_motor_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPosition >&
      motor_positions() const;

  // repeated .MotorVelocity motor_velocities = 2;
  int motor_velocities_size() const;
  private:
  int _internal_motor_velocities_size() const;
  public:
  void clear_motor_velocities();
  ::MotorVelocity* mutable_motor_velocities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorVelocity >*
      mutable_motor_velocities();
  private:
  const ::MotorVelocity& _internal_motor_velocities(int index) const;
  ::MotorVelocity* _internal_add_motor_velocities();
  public:
  const ::MotorVelocity& motor_velocities(int index) const;
  ::MotorVelocity* add_motor_velocities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorVelocity >&
      motor_velocities() const;

  // repeated .MotorForce motor_forces = 3;
  int motor_forces_size() const;
  private:
  int _internal_motor_forces_size() const;
  public:
  void clear_motor_forces();
  ::MotorForce* mutable_motor_forces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorForce >*
      mutable_motor_forces();
  private:
  const ::MotorForce& _internal_motor_forces(int index) const;
  ::MotorForce* _internal_add_motor_forces();
  public:
  const ::MotorForce& motor_forces(int index) const;
  ::MotorForce* add_motor_forces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorForce >&
      motor_forces() const;

  // repeated .MotorTorque motor_torques = 4;
  int motor_torques_size() const;
  private:
  int _internal_motor_torques_size() const;
  public:
  void clear_motor_torques();
  ::MotorTorque* mutable_motor_torques(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorTorque >*
      mutable_motor_torques();
  private:
  const ::MotorTorque& _internal_motor_torques(int index) const;
  ::MotorTorque* _internal_add_motor_torques();
  public:
  const ::MotorTorque& motor_torques(int index) const;
  ::MotorTorque* add_motor_torques();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorTorque >&
      motor_torques() const;

  // repeated .MotorPID motor_pids = 5;
  int motor_pids_size() const;
  private:
  int _internal_motor_pids_size() const;
  public:
  void clear_motor_pids();
  ::MotorPID* mutable_motor_pids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPID >*
      mutable_motor_pids();
  private:
  const ::MotorPID& _internal_motor_pids(int index) const;
  ::MotorPID* _internal_add_motor_pids();
  public:
  const ::MotorPID& motor_pids(int index) const;
  ::MotorPID* add_motor_pids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPID >&
      motor_pids() const;

  // repeated .SensorTimeStep sensor_time_steps = 6;
  int sensor_time_steps_size() const;
  private:
  int _internal_sensor_time_steps_size() const;
  public:
  void clear_sensor_time_steps();
  ::SensorTimeStep* mutable_sensor_time_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorTimeStep >*
      mutable_sensor_time_steps();
  private:
  const ::SensorTimeStep& _internal_sensor_time_steps(int index) const;
  ::SensorTimeStep* _internal_add_sensor_time_steps();
  public:
  const ::SensorTimeStep& sensor_time_steps(int index) const;
  ::SensorTimeStep* add_sensor_time_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorTimeStep >&
      sensor_time_steps() const;

  // repeated .CameraQuality camera_qualities = 7;
  int camera_qualities_size() const;
  private:
  int _internal_camera_qualities_size() const;
  public:
  void clear_camera_qualities();
  ::CameraQuality* mutable_camera_qualities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraQuality >*
      mutable_camera_qualities();
  private:
  const ::CameraQuality& _internal_camera_qualities(int index) const;
  ::CameraQuality* _internal_add_camera_qualities();
  public:
  const ::CameraQuality& camera_qualities(int index) const;
  ::CameraQuality* add_camera_qualities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraQuality >&
      camera_qualities() const;

  // repeated .CameraExposure camera_exposures = 8;
  int camera_exposures_size() const;
  private:
  int _internal_camera_exposures_size() const;
  public:
  void clear_camera_exposures();
  ::CameraExposure* mutable_camera_exposures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraExposure >*
      mutable_camera_exposures();
  private:
  const ::CameraExposure& _internal_camera_exposures(int index) const;
  ::CameraExposure* _internal_add_camera_exposures();
  public:
  const ::CameraExposure& camera_exposures(int index) const;
  ::CameraExposure* add_camera_exposures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraExposure >&
      camera_exposures() const;

  // @@protoc_insertion_point(class_scope:ActuatorRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPosition > motor_positions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorVelocity > motor_velocities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorForce > motor_forces_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorTorque > motor_torques_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPID > motor_pids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorTimeStep > sensor_time_steps_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraQuality > camera_qualities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraExposure > camera_exposures_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// double X = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline double Vector3::_internal_x() const {
  return x_;
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:Vector3.X)
  return _internal_x();
}
inline void Vector3::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vector3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vector3.X)
}

// double Y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline double Vector3::_internal_y() const {
  return y_;
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:Vector3.Y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vector3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vector3.Y)
}

// double Z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline double Vector3::_internal_z() const {
  return z_;
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:Vector3.Z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vector3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Vector3.Z)
}

// -------------------------------------------------------------------

// IMUVector

// double pitch = 1;
inline void IMUVector::clear_pitch() {
  pitch_ = 0;
}
inline double IMUVector::_internal_pitch() const {
  return pitch_;
}
inline double IMUVector::pitch() const {
  // @@protoc_insertion_point(field_get:IMUVector.pitch)
  return _internal_pitch();
}
inline void IMUVector::_internal_set_pitch(double value) {
  
  pitch_ = value;
}
inline void IMUVector::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:IMUVector.pitch)
}

// double roll = 2;
inline void IMUVector::clear_roll() {
  roll_ = 0;
}
inline double IMUVector::_internal_roll() const {
  return roll_;
}
inline double IMUVector::roll() const {
  // @@protoc_insertion_point(field_get:IMUVector.roll)
  return _internal_roll();
}
inline void IMUVector::_internal_set_roll(double value) {
  
  roll_ = value;
}
inline void IMUVector::set_roll(double value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:IMUVector.roll)
}

// double yaw = 3;
inline void IMUVector::clear_yaw() {
  yaw_ = 0;
}
inline double IMUVector::_internal_yaw() const {
  return yaw_;
}
inline double IMUVector::yaw() const {
  // @@protoc_insertion_point(field_get:IMUVector.yaw)
  return _internal_yaw();
}
inline void IMUVector::_internal_set_yaw(double value) {
  
  yaw_ = value;
}
inline void IMUVector::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:IMUVector.yaw)
}

// -------------------------------------------------------------------

// Vector2Int

// int32 X = 1;
inline void Vector2Int::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vector2Int::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vector2Int::x() const {
  // @@protoc_insertion_point(field_get:Vector2Int.X)
  return _internal_x();
}
inline void Vector2Int::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void Vector2Int::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vector2Int.X)
}

// int32 Y = 2;
inline void Vector2Int::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vector2Int::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Vector2Int::y() const {
  // @@protoc_insertion_point(field_get:Vector2Int.Y)
  return _internal_y();
}
inline void Vector2Int::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void Vector2Int::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vector2Int.Y)
}

// -------------------------------------------------------------------

// IMUSensorMeasurement

// string name = 1;
inline void IMUSensorMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& IMUSensorMeasurement::name() const {
  // @@protoc_insertion_point(field_get:IMUSensorMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IMUSensorMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IMUSensorMeasurement.name)
}
inline std::string* IMUSensorMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IMUSensorMeasurement.name)
  return _s;
}
inline const std::string& IMUSensorMeasurement::_internal_name() const {
  return name_.Get();
}
inline void IMUSensorMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IMUSensorMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IMUSensorMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:IMUSensorMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IMUSensorMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:IMUSensorMeasurement.name)
}

// .IMUVector angles = 2;
inline bool IMUSensorMeasurement::_internal_has_angles() const {
  return this != internal_default_instance() && angles_ != nullptr;
}
inline bool IMUSensorMeasurement::has_angles() const {
  return _internal_has_angles();
}
inline void IMUSensorMeasurement::clear_angles() {
  if (GetArenaForAllocation() == nullptr && angles_ != nullptr) {
    delete angles_;
  }
  angles_ = nullptr;
}
inline const ::IMUVector& IMUSensorMeasurement::_internal_angles() const {
  const ::IMUVector* p = angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMUVector&>(
      ::_IMUVector_default_instance_);
}
inline const ::IMUVector& IMUSensorMeasurement::angles() const {
  // @@protoc_insertion_point(field_get:IMUSensorMeasurement.angles)
  return _internal_angles();
}
inline void IMUSensorMeasurement::unsafe_arena_set_allocated_angles(
    ::IMUVector* angles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angles_);
  }
  angles_ = angles;
  if (angles) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMUSensorMeasurement.angles)
}
inline ::IMUVector* IMUSensorMeasurement::release_angles() {
  
  ::IMUVector* temp = angles_;
  angles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMUVector* IMUSensorMeasurement::unsafe_arena_release_angles() {
  // @@protoc_insertion_point(field_release:IMUSensorMeasurement.angles)
  
  ::IMUVector* temp = angles_;
  angles_ = nullptr;
  return temp;
}
inline ::IMUVector* IMUSensorMeasurement::_internal_mutable_angles() {
  
  if (angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMUVector>(GetArenaForAllocation());
    angles_ = p;
  }
  return angles_;
}
inline ::IMUVector* IMUSensorMeasurement::mutable_angles() {
  ::IMUVector* _msg = _internal_mutable_angles();
  // @@protoc_insertion_point(field_mutable:IMUSensorMeasurement.angles)
  return _msg;
}
inline void IMUSensorMeasurement::set_allocated_angles(::IMUVector* angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete angles_;
  }
  if (angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::IMUVector>::GetOwningArena(angles);
    if (message_arena != submessage_arena) {
      angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angles, submessage_arena);
    }
    
  } else {
    
  }
  angles_ = angles;
  // @@protoc_insertion_point(field_set_allocated:IMUSensorMeasurement.angles)
}

// -------------------------------------------------------------------

// PositionSensorMeasurement

// string name = 1;
inline void PositionSensorMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PositionSensorMeasurement::name() const {
  // @@protoc_insertion_point(field_get:PositionSensorMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PositionSensorMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PositionSensorMeasurement.name)
}
inline std::string* PositionSensorMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PositionSensorMeasurement.name)
  return _s;
}
inline const std::string& PositionSensorMeasurement::_internal_name() const {
  return name_.Get();
}
inline void PositionSensorMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PositionSensorMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PositionSensorMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:PositionSensorMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PositionSensorMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:PositionSensorMeasurement.name)
}

// double value = 2;
inline void PositionSensorMeasurement::clear_value() {
  value_ = 0;
}
inline double PositionSensorMeasurement::_internal_value() const {
  return value_;
}
inline double PositionSensorMeasurement::value() const {
  // @@protoc_insertion_point(field_get:PositionSensorMeasurement.value)
  return _internal_value();
}
inline void PositionSensorMeasurement::_internal_set_value(double value) {
  
  value_ = value;
}
inline void PositionSensorMeasurement::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:PositionSensorMeasurement.value)
}

// -------------------------------------------------------------------

// GPSMeasurement

// string name = 1;
inline void GPSMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GPSMeasurement::name() const {
  // @@protoc_insertion_point(field_get:GPSMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GPSMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GPSMeasurement.name)
}
inline std::string* GPSMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GPSMeasurement.name)
  return _s;
}
inline const std::string& GPSMeasurement::_internal_name() const {
  return name_.Get();
}
inline void GPSMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GPSMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GPSMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:GPSMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GPSMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GPSMeasurement.name)
}

// .Vector3 value = 2;
inline bool GPSMeasurement::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool GPSMeasurement::has_value() const {
  return _internal_has_value();
}
inline void GPSMeasurement::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::Vector3& GPSMeasurement::_internal_value() const {
  const ::Vector3* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& GPSMeasurement::value() const {
  // @@protoc_insertion_point(field_get:GPSMeasurement.value)
  return _internal_value();
}
inline void GPSMeasurement::unsafe_arena_set_allocated_value(
    ::Vector3* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GPSMeasurement.value)
}
inline ::Vector3* GPSMeasurement::release_value() {
  
  ::Vector3* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* GPSMeasurement::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:GPSMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::Vector3* GPSMeasurement::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::Vector3* GPSMeasurement::mutable_value() {
  ::Vector3* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:GPSMeasurement.value)
  return _msg;
}
inline void GPSMeasurement::set_allocated_value(::Vector3* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:GPSMeasurement.value)
}

// -------------------------------------------------------------------

// DetectionMeasurement

// string name = 1;
inline void DetectionMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DetectionMeasurement::name() const {
  // @@protoc_insertion_point(field_get:DetectionMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectionMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DetectionMeasurement.name)
}
inline std::string* DetectionMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DetectionMeasurement.name)
  return _s;
}
inline const std::string& DetectionMeasurement::_internal_name() const {
  return name_.Get();
}
inline void DetectionMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectionMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectionMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:DetectionMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectionMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:DetectionMeasurement.name)
}

// .Vector2Int position_on_image = 2;
inline bool DetectionMeasurement::_internal_has_position_on_image() const {
  return this != internal_default_instance() && position_on_image_ != nullptr;
}
inline bool DetectionMeasurement::has_position_on_image() const {
  return _internal_has_position_on_image();
}
inline void DetectionMeasurement::clear_position_on_image() {
  if (GetArenaForAllocation() == nullptr && position_on_image_ != nullptr) {
    delete position_on_image_;
  }
  position_on_image_ = nullptr;
}
inline const ::Vector2Int& DetectionMeasurement::_internal_position_on_image() const {
  const ::Vector2Int* p = position_on_image_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector2Int&>(
      ::_Vector2Int_default_instance_);
}
inline const ::Vector2Int& DetectionMeasurement::position_on_image() const {
  // @@protoc_insertion_point(field_get:DetectionMeasurement.position_on_image)
  return _internal_position_on_image();
}
inline void DetectionMeasurement::unsafe_arena_set_allocated_position_on_image(
    ::Vector2Int* position_on_image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_on_image_);
  }
  position_on_image_ = position_on_image;
  if (position_on_image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DetectionMeasurement.position_on_image)
}
inline ::Vector2Int* DetectionMeasurement::release_position_on_image() {
  
  ::Vector2Int* temp = position_on_image_;
  position_on_image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector2Int* DetectionMeasurement::unsafe_arena_release_position_on_image() {
  // @@protoc_insertion_point(field_release:DetectionMeasurement.position_on_image)
  
  ::Vector2Int* temp = position_on_image_;
  position_on_image_ = nullptr;
  return temp;
}
inline ::Vector2Int* DetectionMeasurement::_internal_mutable_position_on_image() {
  
  if (position_on_image_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector2Int>(GetArenaForAllocation());
    position_on_image_ = p;
  }
  return position_on_image_;
}
inline ::Vector2Int* DetectionMeasurement::mutable_position_on_image() {
  ::Vector2Int* _msg = _internal_mutable_position_on_image();
  // @@protoc_insertion_point(field_mutable:DetectionMeasurement.position_on_image)
  return _msg;
}
inline void DetectionMeasurement::set_allocated_position_on_image(::Vector2Int* position_on_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_on_image_;
  }
  if (position_on_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector2Int>::GetOwningArena(position_on_image);
    if (message_arena != submessage_arena) {
      position_on_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_on_image, submessage_arena);
    }
    
  } else {
    
  }
  position_on_image_ = position_on_image;
  // @@protoc_insertion_point(field_set_allocated:DetectionMeasurement.position_on_image)
}

// .Vector2Int size_on_image = 3;
inline bool DetectionMeasurement::_internal_has_size_on_image() const {
  return this != internal_default_instance() && size_on_image_ != nullptr;
}
inline bool DetectionMeasurement::has_size_on_image() const {
  return _internal_has_size_on_image();
}
inline void DetectionMeasurement::clear_size_on_image() {
  if (GetArenaForAllocation() == nullptr && size_on_image_ != nullptr) {
    delete size_on_image_;
  }
  size_on_image_ = nullptr;
}
inline const ::Vector2Int& DetectionMeasurement::_internal_size_on_image() const {
  const ::Vector2Int* p = size_on_image_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector2Int&>(
      ::_Vector2Int_default_instance_);
}
inline const ::Vector2Int& DetectionMeasurement::size_on_image() const {
  // @@protoc_insertion_point(field_get:DetectionMeasurement.size_on_image)
  return _internal_size_on_image();
}
inline void DetectionMeasurement::unsafe_arena_set_allocated_size_on_image(
    ::Vector2Int* size_on_image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_on_image_);
  }
  size_on_image_ = size_on_image;
  if (size_on_image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DetectionMeasurement.size_on_image)
}
inline ::Vector2Int* DetectionMeasurement::release_size_on_image() {
  
  ::Vector2Int* temp = size_on_image_;
  size_on_image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector2Int* DetectionMeasurement::unsafe_arena_release_size_on_image() {
  // @@protoc_insertion_point(field_release:DetectionMeasurement.size_on_image)
  
  ::Vector2Int* temp = size_on_image_;
  size_on_image_ = nullptr;
  return temp;
}
inline ::Vector2Int* DetectionMeasurement::_internal_mutable_size_on_image() {
  
  if (size_on_image_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector2Int>(GetArenaForAllocation());
    size_on_image_ = p;
  }
  return size_on_image_;
}
inline ::Vector2Int* DetectionMeasurement::mutable_size_on_image() {
  ::Vector2Int* _msg = _internal_mutable_size_on_image();
  // @@protoc_insertion_point(field_mutable:DetectionMeasurement.size_on_image)
  return _msg;
}
inline void DetectionMeasurement::set_allocated_size_on_image(::Vector2Int* size_on_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete size_on_image_;
  }
  if (size_on_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector2Int>::GetOwningArena(size_on_image);
    if (message_arena != submessage_arena) {
      size_on_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size_on_image, submessage_arena);
    }
    
  } else {
    
  }
  size_on_image_ = size_on_image;
  // @@protoc_insertion_point(field_set_allocated:DetectionMeasurement.size_on_image)
}

// double X = 4;
inline void DetectionMeasurement::clear_x() {
  x_ = 0;
}
inline double DetectionMeasurement::_internal_x() const {
  return x_;
}
inline double DetectionMeasurement::x() const {
  // @@protoc_insertion_point(field_get:DetectionMeasurement.X)
  return _internal_x();
}
inline void DetectionMeasurement::_internal_set_x(double value) {
  
  x_ = value;
}
inline void DetectionMeasurement::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:DetectionMeasurement.X)
}

// double Y = 5;
inline void DetectionMeasurement::clear_y() {
  y_ = 0;
}
inline double DetectionMeasurement::_internal_y() const {
  return y_;
}
inline double DetectionMeasurement::y() const {
  // @@protoc_insertion_point(field_get:DetectionMeasurement.Y)
  return _internal_y();
}
inline void DetectionMeasurement::_internal_set_y(double value) {
  
  y_ = value;
}
inline void DetectionMeasurement::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:DetectionMeasurement.Y)
}

// -------------------------------------------------------------------

// AccelerometerMeasurement

// string name = 1;
inline void AccelerometerMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AccelerometerMeasurement::name() const {
  // @@protoc_insertion_point(field_get:AccelerometerMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccelerometerMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AccelerometerMeasurement.name)
}
inline std::string* AccelerometerMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:AccelerometerMeasurement.name)
  return _s;
}
inline const std::string& AccelerometerMeasurement::_internal_name() const {
  return name_.Get();
}
inline void AccelerometerMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccelerometerMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccelerometerMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:AccelerometerMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccelerometerMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:AccelerometerMeasurement.name)
}

// .Vector3 value = 2;
inline bool AccelerometerMeasurement::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool AccelerometerMeasurement::has_value() const {
  return _internal_has_value();
}
inline void AccelerometerMeasurement::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::Vector3& AccelerometerMeasurement::_internal_value() const {
  const ::Vector3* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& AccelerometerMeasurement::value() const {
  // @@protoc_insertion_point(field_get:AccelerometerMeasurement.value)
  return _internal_value();
}
inline void AccelerometerMeasurement::unsafe_arena_set_allocated_value(
    ::Vector3* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AccelerometerMeasurement.value)
}
inline ::Vector3* AccelerometerMeasurement::release_value() {
  
  ::Vector3* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* AccelerometerMeasurement::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:AccelerometerMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::Vector3* AccelerometerMeasurement::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::Vector3* AccelerometerMeasurement::mutable_value() {
  ::Vector3* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:AccelerometerMeasurement.value)
  return _msg;
}
inline void AccelerometerMeasurement::set_allocated_value(::Vector3* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:AccelerometerMeasurement.value)
}

// -------------------------------------------------------------------

// GyroMeasurement

// string name = 1;
inline void GyroMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GyroMeasurement::name() const {
  // @@protoc_insertion_point(field_get:GyroMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GyroMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GyroMeasurement.name)
}
inline std::string* GyroMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GyroMeasurement.name)
  return _s;
}
inline const std::string& GyroMeasurement::_internal_name() const {
  return name_.Get();
}
inline void GyroMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GyroMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GyroMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:GyroMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GyroMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GyroMeasurement.name)
}

// .Vector3 value = 2;
inline bool GyroMeasurement::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool GyroMeasurement::has_value() const {
  return _internal_has_value();
}
inline void GyroMeasurement::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::Vector3& GyroMeasurement::_internal_value() const {
  const ::Vector3* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& GyroMeasurement::value() const {
  // @@protoc_insertion_point(field_get:GyroMeasurement.value)
  return _internal_value();
}
inline void GyroMeasurement::unsafe_arena_set_allocated_value(
    ::Vector3* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GyroMeasurement.value)
}
inline ::Vector3* GyroMeasurement::release_value() {
  
  ::Vector3* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* GyroMeasurement::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:GyroMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::Vector3* GyroMeasurement::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::Vector3* GyroMeasurement::mutable_value() {
  ::Vector3* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:GyroMeasurement.value)
  return _msg;
}
inline void GyroMeasurement::set_allocated_value(::Vector3* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:GyroMeasurement.value)
}

// -------------------------------------------------------------------

// BumperMeasurement

// string name = 1;
inline void BumperMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& BumperMeasurement::name() const {
  // @@protoc_insertion_point(field_get:BumperMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BumperMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BumperMeasurement.name)
}
inline std::string* BumperMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:BumperMeasurement.name)
  return _s;
}
inline const std::string& BumperMeasurement::_internal_name() const {
  return name_.Get();
}
inline void BumperMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BumperMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BumperMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:BumperMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BumperMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:BumperMeasurement.name)
}

// bool value = 2;
inline void BumperMeasurement::clear_value() {
  value_ = false;
}
inline bool BumperMeasurement::_internal_value() const {
  return value_;
}
inline bool BumperMeasurement::value() const {
  // @@protoc_insertion_point(field_get:BumperMeasurement.value)
  return _internal_value();
}
inline void BumperMeasurement::_internal_set_value(bool value) {
  
  value_ = value;
}
inline void BumperMeasurement::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:BumperMeasurement.value)
}

// -------------------------------------------------------------------

// ForceMeasurement

// string name = 1;
inline void ForceMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ForceMeasurement::name() const {
  // @@protoc_insertion_point(field_get:ForceMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForceMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ForceMeasurement.name)
}
inline std::string* ForceMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ForceMeasurement.name)
  return _s;
}
inline const std::string& ForceMeasurement::_internal_name() const {
  return name_.Get();
}
inline void ForceMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ForceMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ForceMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:ForceMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ForceMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ForceMeasurement.name)
}

// double value = 2;
inline void ForceMeasurement::clear_value() {
  value_ = 0;
}
inline double ForceMeasurement::_internal_value() const {
  return value_;
}
inline double ForceMeasurement::value() const {
  // @@protoc_insertion_point(field_get:ForceMeasurement.value)
  return _internal_value();
}
inline void ForceMeasurement::_internal_set_value(double value) {
  
  value_ = value;
}
inline void ForceMeasurement::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ForceMeasurement.value)
}

// -------------------------------------------------------------------

// Force3DMeasurement

// string name = 1;
inline void Force3DMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Force3DMeasurement::name() const {
  // @@protoc_insertion_point(field_get:Force3DMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Force3DMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Force3DMeasurement.name)
}
inline std::string* Force3DMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Force3DMeasurement.name)
  return _s;
}
inline const std::string& Force3DMeasurement::_internal_name() const {
  return name_.Get();
}
inline void Force3DMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Force3DMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Force3DMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:Force3DMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Force3DMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Force3DMeasurement.name)
}

// .Vector3 value = 2;
inline bool Force3DMeasurement::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Force3DMeasurement::has_value() const {
  return _internal_has_value();
}
inline void Force3DMeasurement::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::Vector3& Force3DMeasurement::_internal_value() const {
  const ::Vector3* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& Force3DMeasurement::value() const {
  // @@protoc_insertion_point(field_get:Force3DMeasurement.value)
  return _internal_value();
}
inline void Force3DMeasurement::unsafe_arena_set_allocated_value(
    ::Vector3* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Force3DMeasurement.value)
}
inline ::Vector3* Force3DMeasurement::release_value() {
  
  ::Vector3* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* Force3DMeasurement::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:Force3DMeasurement.value)
  
  ::Vector3* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::Vector3* Force3DMeasurement::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::Vector3* Force3DMeasurement::mutable_value() {
  ::Vector3* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:Force3DMeasurement.value)
  return _msg;
}
inline void Force3DMeasurement::set_allocated_value(::Vector3* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Force3DMeasurement.value)
}

// -------------------------------------------------------------------

// Force6DMeasurement

// string name = 1;
inline void Force6DMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Force6DMeasurement::name() const {
  // @@protoc_insertion_point(field_get:Force6DMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Force6DMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Force6DMeasurement.name)
}
inline std::string* Force6DMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Force6DMeasurement.name)
  return _s;
}
inline const std::string& Force6DMeasurement::_internal_name() const {
  return name_.Get();
}
inline void Force6DMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Force6DMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Force6DMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:Force6DMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Force6DMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Force6DMeasurement.name)
}

// .Vector3 force = 2;
inline bool Force6DMeasurement::_internal_has_force() const {
  return this != internal_default_instance() && force_ != nullptr;
}
inline bool Force6DMeasurement::has_force() const {
  return _internal_has_force();
}
inline void Force6DMeasurement::clear_force() {
  if (GetArenaForAllocation() == nullptr && force_ != nullptr) {
    delete force_;
  }
  force_ = nullptr;
}
inline const ::Vector3& Force6DMeasurement::_internal_force() const {
  const ::Vector3* p = force_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& Force6DMeasurement::force() const {
  // @@protoc_insertion_point(field_get:Force6DMeasurement.force)
  return _internal_force();
}
inline void Force6DMeasurement::unsafe_arena_set_allocated_force(
    ::Vector3* force) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(force_);
  }
  force_ = force;
  if (force) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Force6DMeasurement.force)
}
inline ::Vector3* Force6DMeasurement::release_force() {
  
  ::Vector3* temp = force_;
  force_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* Force6DMeasurement::unsafe_arena_release_force() {
  // @@protoc_insertion_point(field_release:Force6DMeasurement.force)
  
  ::Vector3* temp = force_;
  force_ = nullptr;
  return temp;
}
inline ::Vector3* Force6DMeasurement::_internal_mutable_force() {
  
  if (force_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    force_ = p;
  }
  return force_;
}
inline ::Vector3* Force6DMeasurement::mutable_force() {
  ::Vector3* _msg = _internal_mutable_force();
  // @@protoc_insertion_point(field_mutable:Force6DMeasurement.force)
  return _msg;
}
inline void Force6DMeasurement::set_allocated_force(::Vector3* force) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete force_;
  }
  if (force) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(force);
    if (message_arena != submessage_arena) {
      force = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    
  } else {
    
  }
  force_ = force;
  // @@protoc_insertion_point(field_set_allocated:Force6DMeasurement.force)
}

// .Vector3 torque = 3;
inline bool Force6DMeasurement::_internal_has_torque() const {
  return this != internal_default_instance() && torque_ != nullptr;
}
inline bool Force6DMeasurement::has_torque() const {
  return _internal_has_torque();
}
inline void Force6DMeasurement::clear_torque() {
  if (GetArenaForAllocation() == nullptr && torque_ != nullptr) {
    delete torque_;
  }
  torque_ = nullptr;
}
inline const ::Vector3& Force6DMeasurement::_internal_torque() const {
  const ::Vector3* p = torque_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& Force6DMeasurement::torque() const {
  // @@protoc_insertion_point(field_get:Force6DMeasurement.torque)
  return _internal_torque();
}
inline void Force6DMeasurement::unsafe_arena_set_allocated_torque(
    ::Vector3* torque) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(torque_);
  }
  torque_ = torque;
  if (torque) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Force6DMeasurement.torque)
}
inline ::Vector3* Force6DMeasurement::release_torque() {
  
  ::Vector3* temp = torque_;
  torque_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* Force6DMeasurement::unsafe_arena_release_torque() {
  // @@protoc_insertion_point(field_release:Force6DMeasurement.torque)
  
  ::Vector3* temp = torque_;
  torque_ = nullptr;
  return temp;
}
inline ::Vector3* Force6DMeasurement::_internal_mutable_torque() {
  
  if (torque_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    torque_ = p;
  }
  return torque_;
}
inline ::Vector3* Force6DMeasurement::mutable_torque() {
  ::Vector3* _msg = _internal_mutable_torque();
  // @@protoc_insertion_point(field_mutable:Force6DMeasurement.torque)
  return _msg;
}
inline void Force6DMeasurement::set_allocated_torque(::Vector3* torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete torque_;
  }
  if (torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(torque);
    if (message_arena != submessage_arena) {
      torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:Force6DMeasurement.torque)
}

// -------------------------------------------------------------------

// CameraMeasurement

// string name = 1;
inline void CameraMeasurement::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CameraMeasurement::name() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CameraMeasurement::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CameraMeasurement.name)
}
inline std::string* CameraMeasurement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CameraMeasurement.name)
  return _s;
}
inline const std::string& CameraMeasurement::_internal_name() const {
  return name_.Get();
}
inline void CameraMeasurement::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CameraMeasurement::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CameraMeasurement::release_name() {
  // @@protoc_insertion_point(field_release:CameraMeasurement.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CameraMeasurement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CameraMeasurement.name)
}

// uint32 width = 2;
inline void CameraMeasurement::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraMeasurement::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraMeasurement::width() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.width)
  return _internal_width();
}
inline void CameraMeasurement::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void CameraMeasurement::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CameraMeasurement.width)
}

// uint32 height = 3;
inline void CameraMeasurement::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraMeasurement::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraMeasurement::height() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.height)
  return _internal_height();
}
inline void CameraMeasurement::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void CameraMeasurement::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CameraMeasurement.height)
}

// sint32 quality = 4;
inline void CameraMeasurement::clear_quality() {
  quality_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CameraMeasurement::_internal_quality() const {
  return quality_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CameraMeasurement::quality() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.quality)
  return _internal_quality();
}
inline void CameraMeasurement::_internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  quality_ = value;
}
inline void CameraMeasurement::set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:CameraMeasurement.quality)
}

// bytes image = 5;
inline void CameraMeasurement::clear_image() {
  image_.ClearToEmpty();
}
inline const std::string& CameraMeasurement::image() const {
  // @@protoc_insertion_point(field_get:CameraMeasurement.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CameraMeasurement::set_image(ArgT0&& arg0, ArgT... args) {
 
 image_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CameraMeasurement.image)
}
inline std::string* CameraMeasurement::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:CameraMeasurement.image)
  return _s;
}
inline const std::string& CameraMeasurement::_internal_image() const {
  return image_.Get();
}
inline void CameraMeasurement::_internal_set_image(const std::string& value) {
  
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CameraMeasurement::_internal_mutable_image() {
  
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CameraMeasurement::release_image() {
  // @@protoc_insertion_point(field_release:CameraMeasurement.image)
  return image_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CameraMeasurement::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CameraMeasurement.image)
}

// -------------------------------------------------------------------

// Message

// .Message.MessageType message_type = 1;
inline void Message::clear_message_type() {
  message_type_ = 0;
}
inline ::Message_MessageType Message::_internal_message_type() const {
  return static_cast< ::Message_MessageType >(message_type_);
}
inline ::Message_MessageType Message::message_type() const {
  // @@protoc_insertion_point(field_get:Message.message_type)
  return _internal_message_type();
}
inline void Message::_internal_set_message_type(::Message_MessageType value) {
  
  message_type_ = value;
}
inline void Message::set_message_type(::Message_MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:Message.message_type)
}

// string text = 2;
inline void Message::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& Message::text() const {
  // @@protoc_insertion_point(field_get:Message.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.text)
}
inline std::string* Message::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Message.text)
  return _s;
}
inline const std::string& Message::_internal_text() const {
  return text_.Get();
}
inline void Message::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Message::release_text() {
  // @@protoc_insertion_point(field_release:Message.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Message::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Message.text)
}

// -------------------------------------------------------------------

// SensorMeasurements

// uint32 time = 1;
inline void SensorMeasurements::clear_time() {
  time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorMeasurements::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorMeasurements::time() const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.time)
  return _internal_time();
}
inline void SensorMeasurements::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  time_ = value;
}
inline void SensorMeasurements::set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:SensorMeasurements.time)
}

// uint64 real_time = 2;
inline void SensorMeasurements::clear_real_time() {
  real_time_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorMeasurements::_internal_real_time() const {
  return real_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorMeasurements::real_time() const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.real_time)
  return _internal_real_time();
}
inline void SensorMeasurements::_internal_set_real_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  real_time_ = value;
}
inline void SensorMeasurements::set_real_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_real_time(value);
  // @@protoc_insertion_point(field_set:SensorMeasurements.real_time)
}

// repeated .Message messages = 3;
inline int SensorMeasurements::_internal_messages_size() const {
  return messages_.size();
}
inline int SensorMeasurements::messages_size() const {
  return _internal_messages_size();
}
inline void SensorMeasurements::clear_messages() {
  messages_.Clear();
}
inline ::Message* SensorMeasurements::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.messages)
  return messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message >*
SensorMeasurements::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.messages)
  return &messages_;
}
inline const ::Message& SensorMeasurements::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const ::Message& SensorMeasurements::messages(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.messages)
  return _internal_messages(index);
}
inline ::Message* SensorMeasurements::_internal_add_messages() {
  return messages_.Add();
}
inline ::Message* SensorMeasurements::add_messages() {
  ::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:SensorMeasurements.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message >&
SensorMeasurements::messages() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.messages)
  return messages_;
}

// repeated .AccelerometerMeasurement accelerometers = 4;
inline int SensorMeasurements::_internal_accelerometers_size() const {
  return accelerometers_.size();
}
inline int SensorMeasurements::accelerometers_size() const {
  return _internal_accelerometers_size();
}
inline void SensorMeasurements::clear_accelerometers() {
  accelerometers_.Clear();
}
inline ::AccelerometerMeasurement* SensorMeasurements::mutable_accelerometers(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.accelerometers)
  return accelerometers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AccelerometerMeasurement >*
SensorMeasurements::mutable_accelerometers() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.accelerometers)
  return &accelerometers_;
}
inline const ::AccelerometerMeasurement& SensorMeasurements::_internal_accelerometers(int index) const {
  return accelerometers_.Get(index);
}
inline const ::AccelerometerMeasurement& SensorMeasurements::accelerometers(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.accelerometers)
  return _internal_accelerometers(index);
}
inline ::AccelerometerMeasurement* SensorMeasurements::_internal_add_accelerometers() {
  return accelerometers_.Add();
}
inline ::AccelerometerMeasurement* SensorMeasurements::add_accelerometers() {
  ::AccelerometerMeasurement* _add = _internal_add_accelerometers();
  // @@protoc_insertion_point(field_add:SensorMeasurements.accelerometers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AccelerometerMeasurement >&
SensorMeasurements::accelerometers() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.accelerometers)
  return accelerometers_;
}

// repeated .BumperMeasurement bumpers = 5;
inline int SensorMeasurements::_internal_bumpers_size() const {
  return bumpers_.size();
}
inline int SensorMeasurements::bumpers_size() const {
  return _internal_bumpers_size();
}
inline void SensorMeasurements::clear_bumpers() {
  bumpers_.Clear();
}
inline ::BumperMeasurement* SensorMeasurements::mutable_bumpers(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.bumpers)
  return bumpers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BumperMeasurement >*
SensorMeasurements::mutable_bumpers() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.bumpers)
  return &bumpers_;
}
inline const ::BumperMeasurement& SensorMeasurements::_internal_bumpers(int index) const {
  return bumpers_.Get(index);
}
inline const ::BumperMeasurement& SensorMeasurements::bumpers(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.bumpers)
  return _internal_bumpers(index);
}
inline ::BumperMeasurement* SensorMeasurements::_internal_add_bumpers() {
  return bumpers_.Add();
}
inline ::BumperMeasurement* SensorMeasurements::add_bumpers() {
  ::BumperMeasurement* _add = _internal_add_bumpers();
  // @@protoc_insertion_point(field_add:SensorMeasurements.bumpers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BumperMeasurement >&
SensorMeasurements::bumpers() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.bumpers)
  return bumpers_;
}

// repeated .CameraMeasurement cameras = 6;
inline int SensorMeasurements::_internal_cameras_size() const {
  return cameras_.size();
}
inline int SensorMeasurements::cameras_size() const {
  return _internal_cameras_size();
}
inline void SensorMeasurements::clear_cameras() {
  cameras_.Clear();
}
inline ::CameraMeasurement* SensorMeasurements::mutable_cameras(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.cameras)
  return cameras_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraMeasurement >*
SensorMeasurements::mutable_cameras() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.cameras)
  return &cameras_;
}
inline const ::CameraMeasurement& SensorMeasurements::_internal_cameras(int index) const {
  return cameras_.Get(index);
}
inline const ::CameraMeasurement& SensorMeasurements::cameras(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.cameras)
  return _internal_cameras(index);
}
inline ::CameraMeasurement* SensorMeasurements::_internal_add_cameras() {
  return cameras_.Add();
}
inline ::CameraMeasurement* SensorMeasurements::add_cameras() {
  ::CameraMeasurement* _add = _internal_add_cameras();
  // @@protoc_insertion_point(field_add:SensorMeasurements.cameras)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraMeasurement >&
SensorMeasurements::cameras() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.cameras)
  return cameras_;
}

// repeated .ForceMeasurement forces = 7;
inline int SensorMeasurements::_internal_forces_size() const {
  return forces_.size();
}
inline int SensorMeasurements::forces_size() const {
  return _internal_forces_size();
}
inline void SensorMeasurements::clear_forces() {
  forces_.Clear();
}
inline ::ForceMeasurement* SensorMeasurements::mutable_forces(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.forces)
  return forces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ForceMeasurement >*
SensorMeasurements::mutable_forces() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.forces)
  return &forces_;
}
inline const ::ForceMeasurement& SensorMeasurements::_internal_forces(int index) const {
  return forces_.Get(index);
}
inline const ::ForceMeasurement& SensorMeasurements::forces(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.forces)
  return _internal_forces(index);
}
inline ::ForceMeasurement* SensorMeasurements::_internal_add_forces() {
  return forces_.Add();
}
inline ::ForceMeasurement* SensorMeasurements::add_forces() {
  ::ForceMeasurement* _add = _internal_add_forces();
  // @@protoc_insertion_point(field_add:SensorMeasurements.forces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ForceMeasurement >&
SensorMeasurements::forces() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.forces)
  return forces_;
}

// repeated .Force3DMeasurement force3ds = 8;
inline int SensorMeasurements::_internal_force3ds_size() const {
  return force3ds_.size();
}
inline int SensorMeasurements::force3ds_size() const {
  return _internal_force3ds_size();
}
inline void SensorMeasurements::clear_force3ds() {
  force3ds_.Clear();
}
inline ::Force3DMeasurement* SensorMeasurements::mutable_force3ds(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.force3ds)
  return force3ds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force3DMeasurement >*
SensorMeasurements::mutable_force3ds() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.force3ds)
  return &force3ds_;
}
inline const ::Force3DMeasurement& SensorMeasurements::_internal_force3ds(int index) const {
  return force3ds_.Get(index);
}
inline const ::Force3DMeasurement& SensorMeasurements::force3ds(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.force3ds)
  return _internal_force3ds(index);
}
inline ::Force3DMeasurement* SensorMeasurements::_internal_add_force3ds() {
  return force3ds_.Add();
}
inline ::Force3DMeasurement* SensorMeasurements::add_force3ds() {
  ::Force3DMeasurement* _add = _internal_add_force3ds();
  // @@protoc_insertion_point(field_add:SensorMeasurements.force3ds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force3DMeasurement >&
SensorMeasurements::force3ds() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.force3ds)
  return force3ds_;
}

// repeated .Force6DMeasurement force6ds = 9;
inline int SensorMeasurements::_internal_force6ds_size() const {
  return force6ds_.size();
}
inline int SensorMeasurements::force6ds_size() const {
  return _internal_force6ds_size();
}
inline void SensorMeasurements::clear_force6ds() {
  force6ds_.Clear();
}
inline ::Force6DMeasurement* SensorMeasurements::mutable_force6ds(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.force6ds)
  return force6ds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force6DMeasurement >*
SensorMeasurements::mutable_force6ds() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.force6ds)
  return &force6ds_;
}
inline const ::Force6DMeasurement& SensorMeasurements::_internal_force6ds(int index) const {
  return force6ds_.Get(index);
}
inline const ::Force6DMeasurement& SensorMeasurements::force6ds(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.force6ds)
  return _internal_force6ds(index);
}
inline ::Force6DMeasurement* SensorMeasurements::_internal_add_force6ds() {
  return force6ds_.Add();
}
inline ::Force6DMeasurement* SensorMeasurements::add_force6ds() {
  ::Force6DMeasurement* _add = _internal_add_force6ds();
  // @@protoc_insertion_point(field_add:SensorMeasurements.force6ds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Force6DMeasurement >&
SensorMeasurements::force6ds() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.force6ds)
  return force6ds_;
}

// repeated .GyroMeasurement gyros = 10;
inline int SensorMeasurements::_internal_gyros_size() const {
  return gyros_.size();
}
inline int SensorMeasurements::gyros_size() const {
  return _internal_gyros_size();
}
inline void SensorMeasurements::clear_gyros() {
  gyros_.Clear();
}
inline ::GyroMeasurement* SensorMeasurements::mutable_gyros(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.gyros)
  return gyros_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GyroMeasurement >*
SensorMeasurements::mutable_gyros() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.gyros)
  return &gyros_;
}
inline const ::GyroMeasurement& SensorMeasurements::_internal_gyros(int index) const {
  return gyros_.Get(index);
}
inline const ::GyroMeasurement& SensorMeasurements::gyros(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.gyros)
  return _internal_gyros(index);
}
inline ::GyroMeasurement* SensorMeasurements::_internal_add_gyros() {
  return gyros_.Add();
}
inline ::GyroMeasurement* SensorMeasurements::add_gyros() {
  ::GyroMeasurement* _add = _internal_add_gyros();
  // @@protoc_insertion_point(field_add:SensorMeasurements.gyros)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GyroMeasurement >&
SensorMeasurements::gyros() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.gyros)
  return gyros_;
}

// repeated .PositionSensorMeasurement position_sensors = 11;
inline int SensorMeasurements::_internal_position_sensors_size() const {
  return position_sensors_.size();
}
inline int SensorMeasurements::position_sensors_size() const {
  return _internal_position_sensors_size();
}
inline void SensorMeasurements::clear_position_sensors() {
  position_sensors_.Clear();
}
inline ::PositionSensorMeasurement* SensorMeasurements::mutable_position_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.position_sensors)
  return position_sensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PositionSensorMeasurement >*
SensorMeasurements::mutable_position_sensors() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.position_sensors)
  return &position_sensors_;
}
inline const ::PositionSensorMeasurement& SensorMeasurements::_internal_position_sensors(int index) const {
  return position_sensors_.Get(index);
}
inline const ::PositionSensorMeasurement& SensorMeasurements::position_sensors(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.position_sensors)
  return _internal_position_sensors(index);
}
inline ::PositionSensorMeasurement* SensorMeasurements::_internal_add_position_sensors() {
  return position_sensors_.Add();
}
inline ::PositionSensorMeasurement* SensorMeasurements::add_position_sensors() {
  ::PositionSensorMeasurement* _add = _internal_add_position_sensors();
  // @@protoc_insertion_point(field_add:SensorMeasurements.position_sensors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PositionSensorMeasurement >&
SensorMeasurements::position_sensors() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.position_sensors)
  return position_sensors_;
}

// repeated .GPSMeasurement gps = 12;
inline int SensorMeasurements::_internal_gps_size() const {
  return gps_.size();
}
inline int SensorMeasurements::gps_size() const {
  return _internal_gps_size();
}
inline void SensorMeasurements::clear_gps() {
  gps_.Clear();
}
inline ::GPSMeasurement* SensorMeasurements::mutable_gps(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.gps)
  return gps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GPSMeasurement >*
SensorMeasurements::mutable_gps() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.gps)
  return &gps_;
}
inline const ::GPSMeasurement& SensorMeasurements::_internal_gps(int index) const {
  return gps_.Get(index);
}
inline const ::GPSMeasurement& SensorMeasurements::gps(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.gps)
  return _internal_gps(index);
}
inline ::GPSMeasurement* SensorMeasurements::_internal_add_gps() {
  return gps_.Add();
}
inline ::GPSMeasurement* SensorMeasurements::add_gps() {
  ::GPSMeasurement* _add = _internal_add_gps();
  // @@protoc_insertion_point(field_add:SensorMeasurements.gps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GPSMeasurement >&
SensorMeasurements::gps() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.gps)
  return gps_;
}

// repeated .DetectionMeasurement objects = 13;
inline int SensorMeasurements::_internal_objects_size() const {
  return objects_.size();
}
inline int SensorMeasurements::objects_size() const {
  return _internal_objects_size();
}
inline void SensorMeasurements::clear_objects() {
  objects_.Clear();
}
inline ::DetectionMeasurement* SensorMeasurements::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DetectionMeasurement >*
SensorMeasurements::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.objects)
  return &objects_;
}
inline const ::DetectionMeasurement& SensorMeasurements::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::DetectionMeasurement& SensorMeasurements::objects(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.objects)
  return _internal_objects(index);
}
inline ::DetectionMeasurement* SensorMeasurements::_internal_add_objects() {
  return objects_.Add();
}
inline ::DetectionMeasurement* SensorMeasurements::add_objects() {
  ::DetectionMeasurement* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:SensorMeasurements.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DetectionMeasurement >&
SensorMeasurements::objects() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.objects)
  return objects_;
}

// repeated .IMUSensorMeasurement imu = 14;
inline int SensorMeasurements::_internal_imu_size() const {
  return imu_.size();
}
inline int SensorMeasurements::imu_size() const {
  return _internal_imu_size();
}
inline void SensorMeasurements::clear_imu() {
  imu_.Clear();
}
inline ::IMUSensorMeasurement* SensorMeasurements::mutable_imu(int index) {
  // @@protoc_insertion_point(field_mutable:SensorMeasurements.imu)
  return imu_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMUSensorMeasurement >*
SensorMeasurements::mutable_imu() {
  // @@protoc_insertion_point(field_mutable_list:SensorMeasurements.imu)
  return &imu_;
}
inline const ::IMUSensorMeasurement& SensorMeasurements::_internal_imu(int index) const {
  return imu_.Get(index);
}
inline const ::IMUSensorMeasurement& SensorMeasurements::imu(int index) const {
  // @@protoc_insertion_point(field_get:SensorMeasurements.imu)
  return _internal_imu(index);
}
inline ::IMUSensorMeasurement* SensorMeasurements::_internal_add_imu() {
  return imu_.Add();
}
inline ::IMUSensorMeasurement* SensorMeasurements::add_imu() {
  ::IMUSensorMeasurement* _add = _internal_add_imu();
  // @@protoc_insertion_point(field_add:SensorMeasurements.imu)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMUSensorMeasurement >&
SensorMeasurements::imu() const {
  // @@protoc_insertion_point(field_list:SensorMeasurements.imu)
  return imu_;
}

// -------------------------------------------------------------------

// MotorPosition

// string name = 1;
inline void MotorPosition::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MotorPosition::name() const {
  // @@protoc_insertion_point(field_get:MotorPosition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MotorPosition::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MotorPosition.name)
}
inline std::string* MotorPosition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MotorPosition.name)
  return _s;
}
inline const std::string& MotorPosition::_internal_name() const {
  return name_.Get();
}
inline void MotorPosition::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MotorPosition::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MotorPosition::release_name() {
  // @@protoc_insertion_point(field_release:MotorPosition.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MotorPosition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:MotorPosition.name)
}

// double position = 2;
inline void MotorPosition::clear_position() {
  position_ = 0;
}
inline double MotorPosition::_internal_position() const {
  return position_;
}
inline double MotorPosition::position() const {
  // @@protoc_insertion_point(field_get:MotorPosition.position)
  return _internal_position();
}
inline void MotorPosition::_internal_set_position(double value) {
  
  position_ = value;
}
inline void MotorPosition::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:MotorPosition.position)
}

// -------------------------------------------------------------------

// MotorVelocity

// string name = 1;
inline void MotorVelocity::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MotorVelocity::name() const {
  // @@protoc_insertion_point(field_get:MotorVelocity.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MotorVelocity::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MotorVelocity.name)
}
inline std::string* MotorVelocity::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MotorVelocity.name)
  return _s;
}
inline const std::string& MotorVelocity::_internal_name() const {
  return name_.Get();
}
inline void MotorVelocity::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MotorVelocity::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MotorVelocity::release_name() {
  // @@protoc_insertion_point(field_release:MotorVelocity.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MotorVelocity::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:MotorVelocity.name)
}

// double velocity = 2;
inline void MotorVelocity::clear_velocity() {
  velocity_ = 0;
}
inline double MotorVelocity::_internal_velocity() const {
  return velocity_;
}
inline double MotorVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:MotorVelocity.velocity)
  return _internal_velocity();
}
inline void MotorVelocity::_internal_set_velocity(double value) {
  
  velocity_ = value;
}
inline void MotorVelocity::set_velocity(double value) {
  _internal_set_velocity(value);
  // @@protoc_insertion_point(field_set:MotorVelocity.velocity)
}

// -------------------------------------------------------------------

// MotorForce

// string name = 1;
inline void MotorForce::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MotorForce::name() const {
  // @@protoc_insertion_point(field_get:MotorForce.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MotorForce::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MotorForce.name)
}
inline std::string* MotorForce::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MotorForce.name)
  return _s;
}
inline const std::string& MotorForce::_internal_name() const {
  return name_.Get();
}
inline void MotorForce::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MotorForce::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MotorForce::release_name() {
  // @@protoc_insertion_point(field_release:MotorForce.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MotorForce::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:MotorForce.name)
}

// double force = 2;
inline void MotorForce::clear_force() {
  force_ = 0;
}
inline double MotorForce::_internal_force() const {
  return force_;
}
inline double MotorForce::force() const {
  // @@protoc_insertion_point(field_get:MotorForce.force)
  return _internal_force();
}
inline void MotorForce::_internal_set_force(double value) {
  
  force_ = value;
}
inline void MotorForce::set_force(double value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:MotorForce.force)
}

// -------------------------------------------------------------------

// MotorTorque

// string name = 1;
inline void MotorTorque::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MotorTorque::name() const {
  // @@protoc_insertion_point(field_get:MotorTorque.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MotorTorque::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MotorTorque.name)
}
inline std::string* MotorTorque::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MotorTorque.name)
  return _s;
}
inline const std::string& MotorTorque::_internal_name() const {
  return name_.Get();
}
inline void MotorTorque::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MotorTorque::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MotorTorque::release_name() {
  // @@protoc_insertion_point(field_release:MotorTorque.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MotorTorque::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:MotorTorque.name)
}

// double torque = 2;
inline void MotorTorque::clear_torque() {
  torque_ = 0;
}
inline double MotorTorque::_internal_torque() const {
  return torque_;
}
inline double MotorTorque::torque() const {
  // @@protoc_insertion_point(field_get:MotorTorque.torque)
  return _internal_torque();
}
inline void MotorTorque::_internal_set_torque(double value) {
  
  torque_ = value;
}
inline void MotorTorque::set_torque(double value) {
  _internal_set_torque(value);
  // @@protoc_insertion_point(field_set:MotorTorque.torque)
}

// -------------------------------------------------------------------

// MotorPID

// string name = 1;
inline void MotorPID::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MotorPID::name() const {
  // @@protoc_insertion_point(field_get:MotorPID.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MotorPID::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MotorPID.name)
}
inline std::string* MotorPID::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MotorPID.name)
  return _s;
}
inline const std::string& MotorPID::_internal_name() const {
  return name_.Get();
}
inline void MotorPID::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MotorPID::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MotorPID::release_name() {
  // @@protoc_insertion_point(field_release:MotorPID.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MotorPID::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:MotorPID.name)
}

// .Vector3 PID = 2;
inline bool MotorPID::_internal_has_pid() const {
  return this != internal_default_instance() && pid_ != nullptr;
}
inline bool MotorPID::has_pid() const {
  return _internal_has_pid();
}
inline void MotorPID::clear_pid() {
  if (GetArenaForAllocation() == nullptr && pid_ != nullptr) {
    delete pid_;
  }
  pid_ = nullptr;
}
inline const ::Vector3& MotorPID::_internal_pid() const {
  const ::Vector3* p = pid_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& MotorPID::pid() const {
  // @@protoc_insertion_point(field_get:MotorPID.PID)
  return _internal_pid();
}
inline void MotorPID::unsafe_arena_set_allocated_pid(
    ::Vector3* pid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pid_);
  }
  pid_ = pid;
  if (pid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MotorPID.PID)
}
inline ::Vector3* MotorPID::release_pid() {
  
  ::Vector3* temp = pid_;
  pid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* MotorPID::unsafe_arena_release_pid() {
  // @@protoc_insertion_point(field_release:MotorPID.PID)
  
  ::Vector3* temp = pid_;
  pid_ = nullptr;
  return temp;
}
inline ::Vector3* MotorPID::_internal_mutable_pid() {
  
  if (pid_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    pid_ = p;
  }
  return pid_;
}
inline ::Vector3* MotorPID::mutable_pid() {
  ::Vector3* _msg = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:MotorPID.PID)
  return _msg;
}
inline void MotorPID::set_allocated_pid(::Vector3* pid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pid_;
  }
  if (pid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Vector3>::GetOwningArena(pid);
    if (message_arena != submessage_arena) {
      pid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pid, submessage_arena);
    }
    
  } else {
    
  }
  pid_ = pid;
  // @@protoc_insertion_point(field_set_allocated:MotorPID.PID)
}

// -------------------------------------------------------------------

// SensorTimeStep

// string name = 1;
inline void SensorTimeStep::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SensorTimeStep::name() const {
  // @@protoc_insertion_point(field_get:SensorTimeStep.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorTimeStep::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorTimeStep.name)
}
inline std::string* SensorTimeStep::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SensorTimeStep.name)
  return _s;
}
inline const std::string& SensorTimeStep::_internal_name() const {
  return name_.Get();
}
inline void SensorTimeStep::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SensorTimeStep::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SensorTimeStep::release_name() {
  // @@protoc_insertion_point(field_release:SensorTimeStep.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SensorTimeStep::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SensorTimeStep.name)
}

// uint32 timeStep = 2;
inline void SensorTimeStep::clear_timestep() {
  timestep_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorTimeStep::_internal_timestep() const {
  return timestep_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorTimeStep::timestep() const {
  // @@protoc_insertion_point(field_get:SensorTimeStep.timeStep)
  return _internal_timestep();
}
inline void SensorTimeStep::_internal_set_timestep(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timestep_ = value;
}
inline void SensorTimeStep::set_timestep(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestep(value);
  // @@protoc_insertion_point(field_set:SensorTimeStep.timeStep)
}

// -------------------------------------------------------------------

// CameraQuality

// string name = 1;
inline void CameraQuality::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CameraQuality::name() const {
  // @@protoc_insertion_point(field_get:CameraQuality.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CameraQuality::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CameraQuality.name)
}
inline std::string* CameraQuality::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CameraQuality.name)
  return _s;
}
inline const std::string& CameraQuality::_internal_name() const {
  return name_.Get();
}
inline void CameraQuality::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CameraQuality::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CameraQuality::release_name() {
  // @@protoc_insertion_point(field_release:CameraQuality.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CameraQuality::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CameraQuality.name)
}

// sint32 quality = 2;
inline void CameraQuality::clear_quality() {
  quality_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CameraQuality::_internal_quality() const {
  return quality_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CameraQuality::quality() const {
  // @@protoc_insertion_point(field_get:CameraQuality.quality)
  return _internal_quality();
}
inline void CameraQuality::_internal_set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  quality_ = value;
}
inline void CameraQuality::set_quality(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:CameraQuality.quality)
}

// -------------------------------------------------------------------

// CameraExposure

// string name = 1;
inline void CameraExposure::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CameraExposure::name() const {
  // @@protoc_insertion_point(field_get:CameraExposure.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CameraExposure::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CameraExposure.name)
}
inline std::string* CameraExposure::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CameraExposure.name)
  return _s;
}
inline const std::string& CameraExposure::_internal_name() const {
  return name_.Get();
}
inline void CameraExposure::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CameraExposure::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CameraExposure::release_name() {
  // @@protoc_insertion_point(field_release:CameraExposure.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CameraExposure::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CameraExposure.name)
}

// double exposure = 2;
inline void CameraExposure::clear_exposure() {
  exposure_ = 0;
}
inline double CameraExposure::_internal_exposure() const {
  return exposure_;
}
inline double CameraExposure::exposure() const {
  // @@protoc_insertion_point(field_get:CameraExposure.exposure)
  return _internal_exposure();
}
inline void CameraExposure::_internal_set_exposure(double value) {
  
  exposure_ = value;
}
inline void CameraExposure::set_exposure(double value) {
  _internal_set_exposure(value);
  // @@protoc_insertion_point(field_set:CameraExposure.exposure)
}

// -------------------------------------------------------------------

// ActuatorRequests

// repeated .MotorPosition motor_positions = 1;
inline int ActuatorRequests::_internal_motor_positions_size() const {
  return motor_positions_.size();
}
inline int ActuatorRequests::motor_positions_size() const {
  return _internal_motor_positions_size();
}
inline void ActuatorRequests::clear_motor_positions() {
  motor_positions_.Clear();
}
inline ::MotorPosition* ActuatorRequests::mutable_motor_positions(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_positions)
  return motor_positions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPosition >*
ActuatorRequests::mutable_motor_positions() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_positions)
  return &motor_positions_;
}
inline const ::MotorPosition& ActuatorRequests::_internal_motor_positions(int index) const {
  return motor_positions_.Get(index);
}
inline const ::MotorPosition& ActuatorRequests::motor_positions(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_positions)
  return _internal_motor_positions(index);
}
inline ::MotorPosition* ActuatorRequests::_internal_add_motor_positions() {
  return motor_positions_.Add();
}
inline ::MotorPosition* ActuatorRequests::add_motor_positions() {
  ::MotorPosition* _add = _internal_add_motor_positions();
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_positions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPosition >&
ActuatorRequests::motor_positions() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_positions)
  return motor_positions_;
}

// repeated .MotorVelocity motor_velocities = 2;
inline int ActuatorRequests::_internal_motor_velocities_size() const {
  return motor_velocities_.size();
}
inline int ActuatorRequests::motor_velocities_size() const {
  return _internal_motor_velocities_size();
}
inline void ActuatorRequests::clear_motor_velocities() {
  motor_velocities_.Clear();
}
inline ::MotorVelocity* ActuatorRequests::mutable_motor_velocities(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_velocities)
  return motor_velocities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorVelocity >*
ActuatorRequests::mutable_motor_velocities() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_velocities)
  return &motor_velocities_;
}
inline const ::MotorVelocity& ActuatorRequests::_internal_motor_velocities(int index) const {
  return motor_velocities_.Get(index);
}
inline const ::MotorVelocity& ActuatorRequests::motor_velocities(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_velocities)
  return _internal_motor_velocities(index);
}
inline ::MotorVelocity* ActuatorRequests::_internal_add_motor_velocities() {
  return motor_velocities_.Add();
}
inline ::MotorVelocity* ActuatorRequests::add_motor_velocities() {
  ::MotorVelocity* _add = _internal_add_motor_velocities();
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_velocities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorVelocity >&
ActuatorRequests::motor_velocities() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_velocities)
  return motor_velocities_;
}

// repeated .MotorForce motor_forces = 3;
inline int ActuatorRequests::_internal_motor_forces_size() const {
  return motor_forces_.size();
}
inline int ActuatorRequests::motor_forces_size() const {
  return _internal_motor_forces_size();
}
inline void ActuatorRequests::clear_motor_forces() {
  motor_forces_.Clear();
}
inline ::MotorForce* ActuatorRequests::mutable_motor_forces(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_forces)
  return motor_forces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorForce >*
ActuatorRequests::mutable_motor_forces() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_forces)
  return &motor_forces_;
}
inline const ::MotorForce& ActuatorRequests::_internal_motor_forces(int index) const {
  return motor_forces_.Get(index);
}
inline const ::MotorForce& ActuatorRequests::motor_forces(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_forces)
  return _internal_motor_forces(index);
}
inline ::MotorForce* ActuatorRequests::_internal_add_motor_forces() {
  return motor_forces_.Add();
}
inline ::MotorForce* ActuatorRequests::add_motor_forces() {
  ::MotorForce* _add = _internal_add_motor_forces();
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_forces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorForce >&
ActuatorRequests::motor_forces() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_forces)
  return motor_forces_;
}

// repeated .MotorTorque motor_torques = 4;
inline int ActuatorRequests::_internal_motor_torques_size() const {
  return motor_torques_.size();
}
inline int ActuatorRequests::motor_torques_size() const {
  return _internal_motor_torques_size();
}
inline void ActuatorRequests::clear_motor_torques() {
  motor_torques_.Clear();
}
inline ::MotorTorque* ActuatorRequests::mutable_motor_torques(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_torques)
  return motor_torques_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorTorque >*
ActuatorRequests::mutable_motor_torques() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_torques)
  return &motor_torques_;
}
inline const ::MotorTorque& ActuatorRequests::_internal_motor_torques(int index) const {
  return motor_torques_.Get(index);
}
inline const ::MotorTorque& ActuatorRequests::motor_torques(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_torques)
  return _internal_motor_torques(index);
}
inline ::MotorTorque* ActuatorRequests::_internal_add_motor_torques() {
  return motor_torques_.Add();
}
inline ::MotorTorque* ActuatorRequests::add_motor_torques() {
  ::MotorTorque* _add = _internal_add_motor_torques();
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_torques)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorTorque >&
ActuatorRequests::motor_torques() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_torques)
  return motor_torques_;
}

// repeated .MotorPID motor_pids = 5;
inline int ActuatorRequests::_internal_motor_pids_size() const {
  return motor_pids_.size();
}
inline int ActuatorRequests::motor_pids_size() const {
  return _internal_motor_pids_size();
}
inline void ActuatorRequests::clear_motor_pids() {
  motor_pids_.Clear();
}
inline ::MotorPID* ActuatorRequests::mutable_motor_pids(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.motor_pids)
  return motor_pids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPID >*
ActuatorRequests::mutable_motor_pids() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.motor_pids)
  return &motor_pids_;
}
inline const ::MotorPID& ActuatorRequests::_internal_motor_pids(int index) const {
  return motor_pids_.Get(index);
}
inline const ::MotorPID& ActuatorRequests::motor_pids(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.motor_pids)
  return _internal_motor_pids(index);
}
inline ::MotorPID* ActuatorRequests::_internal_add_motor_pids() {
  return motor_pids_.Add();
}
inline ::MotorPID* ActuatorRequests::add_motor_pids() {
  ::MotorPID* _add = _internal_add_motor_pids();
  // @@protoc_insertion_point(field_add:ActuatorRequests.motor_pids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MotorPID >&
ActuatorRequests::motor_pids() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.motor_pids)
  return motor_pids_;
}

// repeated .SensorTimeStep sensor_time_steps = 6;
inline int ActuatorRequests::_internal_sensor_time_steps_size() const {
  return sensor_time_steps_.size();
}
inline int ActuatorRequests::sensor_time_steps_size() const {
  return _internal_sensor_time_steps_size();
}
inline void ActuatorRequests::clear_sensor_time_steps() {
  sensor_time_steps_.Clear();
}
inline ::SensorTimeStep* ActuatorRequests::mutable_sensor_time_steps(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.sensor_time_steps)
  return sensor_time_steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorTimeStep >*
ActuatorRequests::mutable_sensor_time_steps() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.sensor_time_steps)
  return &sensor_time_steps_;
}
inline const ::SensorTimeStep& ActuatorRequests::_internal_sensor_time_steps(int index) const {
  return sensor_time_steps_.Get(index);
}
inline const ::SensorTimeStep& ActuatorRequests::sensor_time_steps(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.sensor_time_steps)
  return _internal_sensor_time_steps(index);
}
inline ::SensorTimeStep* ActuatorRequests::_internal_add_sensor_time_steps() {
  return sensor_time_steps_.Add();
}
inline ::SensorTimeStep* ActuatorRequests::add_sensor_time_steps() {
  ::SensorTimeStep* _add = _internal_add_sensor_time_steps();
  // @@protoc_insertion_point(field_add:ActuatorRequests.sensor_time_steps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorTimeStep >&
ActuatorRequests::sensor_time_steps() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.sensor_time_steps)
  return sensor_time_steps_;
}

// repeated .CameraQuality camera_qualities = 7;
inline int ActuatorRequests::_internal_camera_qualities_size() const {
  return camera_qualities_.size();
}
inline int ActuatorRequests::camera_qualities_size() const {
  return _internal_camera_qualities_size();
}
inline void ActuatorRequests::clear_camera_qualities() {
  camera_qualities_.Clear();
}
inline ::CameraQuality* ActuatorRequests::mutable_camera_qualities(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.camera_qualities)
  return camera_qualities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraQuality >*
ActuatorRequests::mutable_camera_qualities() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.camera_qualities)
  return &camera_qualities_;
}
inline const ::CameraQuality& ActuatorRequests::_internal_camera_qualities(int index) const {
  return camera_qualities_.Get(index);
}
inline const ::CameraQuality& ActuatorRequests::camera_qualities(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.camera_qualities)
  return _internal_camera_qualities(index);
}
inline ::CameraQuality* ActuatorRequests::_internal_add_camera_qualities() {
  return camera_qualities_.Add();
}
inline ::CameraQuality* ActuatorRequests::add_camera_qualities() {
  ::CameraQuality* _add = _internal_add_camera_qualities();
  // @@protoc_insertion_point(field_add:ActuatorRequests.camera_qualities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraQuality >&
ActuatorRequests::camera_qualities() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.camera_qualities)
  return camera_qualities_;
}

// repeated .CameraExposure camera_exposures = 8;
inline int ActuatorRequests::_internal_camera_exposures_size() const {
  return camera_exposures_.size();
}
inline int ActuatorRequests::camera_exposures_size() const {
  return _internal_camera_exposures_size();
}
inline void ActuatorRequests::clear_camera_exposures() {
  camera_exposures_.Clear();
}
inline ::CameraExposure* ActuatorRequests::mutable_camera_exposures(int index) {
  // @@protoc_insertion_point(field_mutable:ActuatorRequests.camera_exposures)
  return camera_exposures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraExposure >*
ActuatorRequests::mutable_camera_exposures() {
  // @@protoc_insertion_point(field_mutable_list:ActuatorRequests.camera_exposures)
  return &camera_exposures_;
}
inline const ::CameraExposure& ActuatorRequests::_internal_camera_exposures(int index) const {
  return camera_exposures_.Get(index);
}
inline const ::CameraExposure& ActuatorRequests::camera_exposures(int index) const {
  // @@protoc_insertion_point(field_get:ActuatorRequests.camera_exposures)
  return _internal_camera_exposures(index);
}
inline ::CameraExposure* ActuatorRequests::_internal_add_camera_exposures() {
  return camera_exposures_.Add();
}
inline ::CameraExposure* ActuatorRequests::add_camera_exposures() {
  ::CameraExposure* _add = _internal_add_camera_exposures();
  // @@protoc_insertion_point(field_add:ActuatorRequests.camera_exposures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CameraExposure >&
ActuatorRequests::camera_exposures() const {
  // @@protoc_insertion_point(field_list:ActuatorRequests.camera_exposures)
  return camera_exposures_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Message_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Message_MessageType>() {
  return ::Message_MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
